<audio title="54 _ å­˜å‚¨è™šæ‹ŸåŒ–ï¼ˆä¸‹ï¼‰ï¼šå¦‚ä½•å»ºç«‹è‡ªå·±ä¿ç®¡çš„å•ç‹¬æ¡£æ¡ˆåº“ï¼Ÿ" src="https://static001.geekbang.org/resource/audio/96/9a/96ae957ba80acda102c44d661ea0be9a.mp3" controls="controls"></audio> 
<p>ä¸Šä¸€èŠ‚ï¼Œæˆ‘ä»¬è®²äº†qemuå¯åŠ¨è¿‡ç¨‹ä¸­çš„å­˜å‚¨è™šæ‹ŸåŒ–ã€‚å¥½äº†ï¼Œç°åœ¨qemuå¯åŠ¨äº†ï¼Œç¡¬ç›˜è®¾å¤‡æ–‡ä»¶å·²ç»æ‰“å¼€äº†ã€‚é‚£å¦‚æœæˆ‘ä»¬è¦å¾€è™šæ‹Ÿæœºçš„ä¸€ä¸ªè¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿæœ€ç»ˆè¿™ä¸ªæ–‡ä»¶åˆæ˜¯å¦‚ä½•è½åˆ°å®¿ä¸»æœºä¸Šçš„ç¡¬ç›˜æ–‡ä»¶çš„å‘¢ï¼Ÿè¿™ä¸€èŠ‚ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹ä¸€çœ‹ã€‚</p><h2>å‰ç«¯è®¾å¤‡é©±åŠ¨virtio_blk</h2><p>è™šæ‹Ÿæœºé‡Œé¢çš„è¿›ç¨‹å†™å…¥ä¸€ä¸ªæ–‡ä»¶ï¼Œå½“ç„¶è¦é€šè¿‡æ–‡ä»¶ç³»ç»Ÿã€‚æ•´ä¸ªè¿‡ç¨‹å’Œå’±ä»¬åœ¨<a href="https://time.geekbang.org/column/article/97876">æ–‡ä»¶ç³»ç»Ÿ</a>é‚£ä¸€èŠ‚è®²çš„è¿‡ç¨‹æ²¡æœ‰åŒºåˆ«ã€‚åªæ˜¯åˆ°äº†è®¾å¤‡é©±åŠ¨å±‚ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„å°±ä¸æ˜¯æ™®é€šçš„ç¡¬ç›˜é©±åŠ¨äº†ï¼Œè€Œæ˜¯virtioçš„é©±åŠ¨ã€‚</p><p>virtioçš„é©±åŠ¨ç¨‹åºä»£ç åœ¨Linuxæ“ä½œç³»ç»Ÿçš„æºä»£ç é‡Œé¢ï¼Œæ–‡ä»¶åå«drivers/block/virtio_blk.cã€‚</p><pre><code>static int __init init(void)
{
	int error;
	virtblk_wq = alloc_workqueue(&quot;virtio-blk&quot;, 0, 0);
	major = register_blkdev(0, &quot;virtblk&quot;);
	error = register_virtio_driver(&amp;virtio_blk);
......
}

module_init(init);
module_exit(fini);

MODULE_DEVICE_TABLE(virtio, id_table);
MODULE_DESCRIPTION(&quot;Virtio block driver&quot;);
MODULE_LICENSE(&quot;GPL&quot;);

static struct virtio_driver virtio_blk = {
......
	.driver.name			= KBUILD_MODNAME,
	.driver.owner			= THIS_MODULE,
	.id_table			= id_table,
	.probe				= virtblk_probe,
	.remove				= virtblk_remove,
......
};
</code></pre><p>å‰é¢æˆ‘ä»¬ä»‹ç»è¿‡è®¾å¤‡é©±åŠ¨ç¨‹åºï¼Œä»è¿™é‡Œçš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°éå¸¸ç†Ÿæ‚‰çš„ç»“æ„ã€‚å®ƒä¼šåˆ›å»ºä¸€ä¸ªworkqueueï¼Œæ³¨å†Œä¸€ä¸ªå—è®¾å¤‡ï¼Œå¹¶è·å¾—ä¸€ä¸ªä¸»è®¾å¤‡å·ï¼Œç„¶åæ³¨å†Œä¸€ä¸ªé©±åŠ¨å‡½æ•°virtio_blkã€‚</p><p>å½“ä¸€ä¸ªè®¾å¤‡é©±åŠ¨ä½œä¸ºä¸€ä¸ªå†…æ ¸æ¨¡å—è¢«åˆå§‹åŒ–çš„æ—¶å€™ï¼Œprobeå‡½æ•°ä¼šè¢«è°ƒç”¨ï¼Œå› è€Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹virtblk_probeã€‚</p><pre><code>static int virtblk_probe(struct virtio_device *vdev)
{
	struct virtio_blk *vblk;
	struct request_queue *q;
......
	vdev-&gt;priv = vblk = kmalloc(sizeof(*vblk), GFP_KERNEL);
	vblk-&gt;vdev = vdev;
	vblk-&gt;sg_elems = sg_elems;
	INIT_WORK(&amp;vblk-&gt;config_work, virtblk_config_changed_work);
......
	err = init_vq(vblk);
......
	vblk-&gt;disk = alloc_disk(1 &lt;&lt; PART_BITS);
	memset(&amp;vblk-&gt;tag_set, 0, sizeof(vblk-&gt;tag_set));
	vblk-&gt;tag_set.ops = &amp;virtio_mq_ops;
	vblk-&gt;tag_set.queue_depth = virtblk_queue_depth;
	vblk-&gt;tag_set.numa_node = NUMA_NO_NODE;
	vblk-&gt;tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
	vblk-&gt;tag_set.cmd_size =
		sizeof(struct virtblk_req) +
		sizeof(struct scatterlist) * sg_elems;
	vblk-&gt;tag_set.driver_data = vblk;
	vblk-&gt;tag_set.nr_hw_queues = vblk-&gt;num_vqs;
	err = blk_mq_alloc_tag_set(&amp;vblk-&gt;tag_set);
......
	q = blk_mq_init_queue(&amp;vblk-&gt;tag_set);
	vblk-&gt;disk-&gt;queue = q;
	q-&gt;queuedata = vblk;
	virtblk_name_format(&quot;vd&quot;, index, vblk-&gt;disk-&gt;disk_name, DISK_NAME_LEN);
	vblk-&gt;disk-&gt;major = major;
	vblk-&gt;disk-&gt;first_minor = index_to_minor(index);
	vblk-&gt;disk-&gt;private_data = vblk;
	vblk-&gt;disk-&gt;fops = &amp;virtblk_fops;
	vblk-&gt;disk-&gt;flags |= GENHD_FL_EXT_DEVT;
	vblk-&gt;index = index;
......
	device_add_disk(&amp;vdev-&gt;dev, vblk-&gt;disk);
	err = device_create_file(disk_to_dev(vblk-&gt;disk), &amp;dev_attr_serial);
......
}
</code></pre><p>åœ¨virtblk_probeä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹åˆ°çš„æ˜¯struct request_queueï¼Œè¿™æ˜¯æ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰çš„ä¸€ä¸ªé˜Ÿåˆ—ã€‚è¿˜è®°å¾—å—ï¼Ÿå®ƒæœ‰ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯make_request_fnå‡½æ•°ï¼Œç”¨äºç”Ÿæˆrequestï¼›å¦ä¸€ä¸ªæ˜¯request_fnå‡½æ•°ï¼Œç”¨äºå¤„ç†requestã€‚</p><!-- [[[read_end]]] --><p>è¿™ä¸ªrequest_queueçš„åˆå§‹åŒ–è¿‡ç¨‹åœ¨blk_mq_init_queueä¸­ã€‚å®ƒä¼šè°ƒç”¨blk_mq_init_allocated_queue-&gt;blk_queue_make_requestã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬å¯ä»¥å°†make_request_fnå‡½æ•°è®¾ç½®ä¸ºblk_mq_make_requestï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦ä¸Šå±‚æœ‰å†™å…¥è¯·æ±‚ï¼Œæˆ‘ä»¬å°±é€šè¿‡blk_mq_make_requestè¿™ä¸ªå‡½æ•°ï¼Œå°†è¯·æ±‚æ”¾å…¥request_queueé˜Ÿåˆ—ä¸­ã€‚</p><p>å¦å¤–ï¼Œåœ¨virtblk_probeä¸­ï¼Œæˆ‘ä»¬ä¼šåˆå§‹åŒ–ä¸€ä¸ªgendiskã€‚å‰é¢æˆ‘ä»¬ä¹Ÿè®²äº†ï¼Œæ¯ä¸€ä¸ªå—è®¾å¤‡éƒ½æœ‰è¿™æ ·ä¸€ä¸ªç»“æ„ã€‚</p><p>åœ¨virtblk_probeä¸­ï¼Œè¿˜æœ‰ä¸€ä»¶é‡è¦çš„äº‹æƒ…å°±æ˜¯ï¼Œinit_vqä¼šæ¥åˆå§‹åŒ–virtqueueã€‚</p><pre><code>static int init_vq(struct virtio_blk *vblk)
{
	int err;
	int i;
	vq_callback_t **callbacks;
	const char **names;
	struct virtqueue **vqs;
	unsigned short num_vqs;
	struct virtio_device *vdev = vblk-&gt;vdev;
......
	vblk-&gt;vqs = kmalloc_array(num_vqs, sizeof(*vblk-&gt;vqs), GFP_KERNEL);
	names = kmalloc_array(num_vqs, sizeof(*names), GFP_KERNEL);
	callbacks = kmalloc_array(num_vqs, sizeof(*callbacks), GFP_KERNEL);
	vqs = kmalloc_array(num_vqs, sizeof(*vqs), GFP_KERNEL);
......
	for (i = 0; i &lt; num_vqs; i++) {
		callbacks[i] = virtblk_done;
		names[i] = vblk-&gt;vqs[i].name;
	}

	/* Discover virtqueues and write information to configuration.  */
	err = virtio_find_vqs(vdev, num_vqs, vqs, callbacks, names, &amp;desc);

	for (i = 0; i &lt; num_vqs; i++) {
		vblk-&gt;vqs[i].vq = vqs[i];
	}
	vblk-&gt;num_vqs = num_vqs;
......
}
</code></pre><p>æŒ‰ç…§ä¸Šé¢çš„åŸç†æ¥è¯´ï¼Œvirtqueueæ˜¯ä¸€ä¸ªä»‹äºå®¢æˆ·æœºå‰ç«¯å’Œqemuåç«¯çš„ä¸€ä¸ªç»“æ„ï¼Œç”¨äºåœ¨è¿™ä¸¤ç«¯ä¹‹é—´ä¼ é€’æ•°æ®ã€‚è¿™é‡Œå»ºç«‹çš„struct virtqueueæ˜¯å®¢æˆ·æœºå‰ç«¯å¯¹äºé˜Ÿåˆ—çš„ç®¡ç†çš„æ•°æ®ç»“æ„ï¼Œåœ¨å®¢æˆ·æœºçš„linuxå†…æ ¸ä¸­é€šè¿‡kmalloc_arrayè¿›è¡Œåˆ†é…ã€‚</p><p>è€Œé˜Ÿåˆ—çš„å®ä½“éœ€è¦é€šè¿‡å‡½æ•°virtio_find_vqsæŸ¥æ‰¾æˆ–è€…ç”Ÿæˆï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬è¿˜æŠŠcallbackå‡½æ•°æŒ‡å®šä¸ºvirtblk_doneã€‚å½“bufferä½¿ç”¨å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è°ƒç”¨è¿™ä¸ªcallbackå‡½æ•°è¿›è¡Œé€šçŸ¥ã€‚</p><pre><code>static inline
int virtio_find_vqs(struct virtio_device *vdev, unsigned nvqs,
			struct virtqueue *vqs[], vq_callback_t *callbacks[],
			const char * const names[],
			struct irq_affinity *desc)
{
	return vdev-&gt;config-&gt;find_vqs(vdev, nvqs, vqs, callbacks, names, NULL, desc);
}

static const struct virtio_config_ops virtio_pci_config_ops = {
	.get		= vp_get,
	.set		= vp_set,
	.generation	= vp_generation,
	.get_status	= vp_get_status,
	.set_status	= vp_set_status,
	.reset		= vp_reset,
	.find_vqs	= vp_modern_find_vqs,
	.del_vqs	= vp_del_vqs,
	.get_features	= vp_get_features,
	.finalize_features = vp_finalize_features,
	.bus_name	= vp_bus_name,
	.set_vq_affinity = vp_set_vq_affinity,
	.get_vq_affinity = vp_get_vq_affinity,
};
</code></pre><p>æ ¹æ®virtio_config_opsçš„å®šä¹‰ï¼Œvirtio_find_vqsä¼šè°ƒç”¨vp_modern_find_vqsã€‚</p><pre><code>static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
			      struct virtqueue *vqs[],
			      vq_callback_t *callbacks[],
			      const char * const names[], const bool *ctx,
			      struct irq_affinity *desc)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	struct virtqueue *vq;
	int rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names, ctx, desc);
	/* Select and activate all queues. Has to be done last: once we do
	 * this, there's no way to go back except reset.
	 */
	list_for_each_entry(vq, &amp;vdev-&gt;vqs, list) {
		vp_iowrite16(vq-&gt;index, &amp;vp_dev-&gt;common-&gt;queue_select);
		vp_iowrite16(1, &amp;vp_dev-&gt;common-&gt;queue_enable);
	}

	return 0;
}
</code></pre><p>åœ¨vp_modern_find_vqsä¸­ï¼Œvp_find_vqsä¼šè°ƒç”¨vp_find_vqs_intxã€‚</p><pre><code>static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,
		struct virtqueue *vqs[], vq_callback_t *callbacks[],
		const char * const names[], const bool *ctx)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	int i, err;

	vp_dev-&gt;vqs = kcalloc(nvqs, sizeof(*vp_dev-&gt;vqs), GFP_KERNEL);
	err = request_irq(vp_dev-&gt;pci_dev-&gt;irq, vp_interrupt, IRQF_SHARED,
			dev_name(&amp;vdev-&gt;dev), vp_dev);
	vp_dev-&gt;intx_enabled = 1;
	vp_dev-&gt;per_vq_vectors = false;
	for (i = 0; i &lt; nvqs; ++i) {
		vqs[i] = vp_setup_vq(vdev, i, callbacks[i], names[i],
				     ctx ? ctx[i] : false,
				     VIRTIO_MSI_NO_VECTOR);
......
	}
}
</code></pre><p>åœ¨vp_find_vqs_intxä¸­ï¼Œæˆ‘ä»¬é€šè¿‡request_irqæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptï¼Œå½“è®¾å¤‡çš„é…ç½®ä¿¡æ¯å‘ç”Ÿæ”¹å˜ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œå½“è®¾å¤‡å‘é˜Ÿåˆ—ä¸­å†™å…¥ä¿¡æ¯æ—¶ï¼Œä¹Ÿä¼šäº§ç”Ÿä¸€ä¸ªä¸­æ–­ï¼Œæˆ‘ä»¬ç§°ä¸ºvqä¸­æ–­ï¼Œä¸­æ–­å¤„ç†å‡½æ•°éœ€è¦è°ƒç”¨ç›¸åº”çš„é˜Ÿåˆ—çš„å›è°ƒå‡½æ•°ã€‚</p><p>ç„¶åï¼Œæˆ‘ä»¬æ ¹æ®é˜Ÿåˆ—çš„æ•°ç›®ï¼Œä¾æ¬¡è°ƒç”¨vp_setup_vqï¼Œå®Œæˆvirtqueueã€vringçš„åˆ†é…å’Œåˆå§‹åŒ–ã€‚</p><pre><code>static struct virtqueue *vp_setup_vq(struct virtio_device *vdev, unsigned index,
				     void (*callback)(struct virtqueue *vq),
				     const char *name,
				     bool ctx,
				     u16 msix_vec)
{
	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
	struct virtio_pci_vq_info *info = kmalloc(sizeof *info, GFP_KERNEL);
	struct virtqueue *vq;
	unsigned long flags;
......
	vq = vp_dev-&gt;setup_vq(vp_dev, info, index, callback, name, ctx,
			      msix_vec);
	info-&gt;vq = vq;
	if (callback) {
		spin_lock_irqsave(&amp;vp_dev-&gt;lock, flags);
		list_add(&amp;info-&gt;node, &amp;vp_dev-&gt;virtqueues);
		spin_unlock_irqrestore(&amp;vp_dev-&gt;lock, flags);
	} else {
		INIT_LIST_HEAD(&amp;info-&gt;node);
	}
	vp_dev-&gt;vqs[index] = info;
	return vq;
}

static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,
				  struct virtio_pci_vq_info *info,
				  unsigned index,
				  void (*callback)(struct virtqueue *vq),
				  const char *name,
				  bool ctx,
				  u16 msix_vec)
{
	struct virtio_pci_common_cfg __iomem *cfg = vp_dev-&gt;common;
	struct virtqueue *vq;
	u16 num, off;
	int err;

	/* Select the queue we're interested in */
	vp_iowrite16(index, &amp;cfg-&gt;queue_select);

	/* Check if queue is either not available or already active. */
	num = vp_ioread16(&amp;cfg-&gt;queue_size);

	/* get offset of notification word for this vq */
	off = vp_ioread16(&amp;cfg-&gt;queue_notify_off);

	info-&gt;msix_vector = msix_vec;

	/* create the vring */
	vq = vring_create_virtqueue(index, num,
				    SMP_CACHE_BYTES, &amp;vp_dev-&gt;vdev,
				    true, true, ctx,
				    vp_notify, callback, name);
	/* activate the queue */
	vp_iowrite16(virtqueue_get_vring_size(vq), &amp;cfg-&gt;queue_size);
	vp_iowrite64_twopart(virtqueue_get_desc_addr(vq),
			     &amp;cfg-&gt;queue_desc_lo, &amp;cfg-&gt;queue_desc_hi);
	vp_iowrite64_twopart(virtqueue_get_avail_addr(vq),
			     &amp;cfg-&gt;queue_avail_lo, &amp;cfg-&gt;queue_avail_hi);
	vp_iowrite64_twopart(virtqueue_get_used_addr(vq),
			     &amp;cfg-&gt;queue_used_lo, &amp;cfg-&gt;queue_used_hi);
......
	return vq;
}

struct virtqueue *vring_create_virtqueue(
	unsigned int index,
	unsigned int num,
	unsigned int vring_align,
	struct virtio_device *vdev,
	bool weak_barriers,
	bool may_reduce_num,
	bool context,
	bool (*notify)(struct virtqueue *),
	void (*callback)(struct virtqueue *),
	const char *name)
{
	struct virtqueue *vq;
	void *queue = NULL;
	dma_addr_t dma_addr;
	size_t queue_size_in_bytes;
	struct vring vring;

	/* TODO: allocate each queue chunk individually */
	for (; num &amp;&amp; vring_size(num, vring_align) &gt; PAGE_SIZE; num /= 2) {
		queue = vring_alloc_queue(vdev, vring_size(num, vring_align),
					  &amp;dma_addr,
					  GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);
		if (queue)
			break;
	}

	if (!queue) {
		/* Try to get a single page. You are my only hope! */
		queue = vring_alloc_queue(vdev, vring_size(num, vring_align),
					  &amp;dma_addr, GFP_KERNEL|__GFP_ZERO);
	}

	queue_size_in_bytes = vring_size(num, vring_align);
	vring_init(&amp;vring, num, queue, vring_align);

	vq = __vring_new_virtqueue(index, vring, vdev, weak_barriers, context, notify, callback, name);

	to_vvq(vq)-&gt;queue_dma_addr = dma_addr;
	to_vvq(vq)-&gt;queue_size_in_bytes = queue_size_in_bytes;
	to_vvq(vq)-&gt;we_own_ring = true;

	return vq;
}
</code></pre><p>åœ¨vring_create_virtqueueä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨vring_alloc_queueï¼Œæ¥åˆ›å»ºé˜Ÿåˆ—æ‰€éœ€è¦çš„å†…å­˜ç©ºé—´ï¼Œç„¶åè°ƒç”¨vring_initåˆå§‹åŒ–ç»“æ„struct vringï¼Œæ¥ç®¡ç†é˜Ÿåˆ—çš„å†…å­˜ç©ºé—´ï¼Œè°ƒç”¨__vring_new_virtqueueï¼Œæ¥åˆ›å»ºstruct vring_virtqueueã€‚</p><p>è¿™ä¸ªç»“æ„çš„ä¸€å¼€å§‹ï¼Œæ˜¯struct virtqueueï¼Œå®ƒä¹Ÿæ˜¯struct virtqueueçš„ä¸€ä¸ªæ‰©å±•ï¼Œç´§æ¥ç€åé¢å°±æ˜¯struct vringã€‚</p><pre><code>struct vring_virtqueue {
	struct virtqueue vq;

	/* Actual memory layout for this queue */
	struct vring vring;
......
}
</code></pre><p>è‡³æ­¤æˆ‘ä»¬å‘ç°ï¼Œè™šæ‹Ÿæœºé‡Œé¢çš„virtioçš„å‰ç«¯æ˜¯è¿™æ ·çš„ç»“æ„ï¼šstruct virtio_deviceé‡Œé¢æœ‰ä¸€ä¸ªstruct vring_virtqueueï¼Œåœ¨struct vring_virtqueueé‡Œé¢æœ‰ä¸€ä¸ªstruct vringã€‚</p><h2>ä¸­é—´virtioé˜Ÿåˆ—çš„ç®¡ç†</h2><p>è¿˜è®°ä¸è®°å¾—æˆ‘ä»¬ä¸Šé¢è®²qemuåˆå§‹åŒ–çš„æ—¶å€™ï¼Œvirtioçš„åç«¯æœ‰æ•°æ®ç»“æ„VirtIODeviceï¼ŒVirtQueueå’Œvringä¸€æ¨¡ä¸€æ ·ï¼Œå‰ç«¯å’Œåç«¯å¯¹åº”èµ·æ¥ï¼Œéƒ½åº”è¯¥æŒ‡å‘åˆšæ‰åˆ›å»ºçš„é‚£ä¸€æ®µå†…å­˜ã€‚</p><p>ç°åœ¨çš„é—®é¢˜æ˜¯ï¼Œæˆ‘ä»¬åˆšæ‰åˆ†é…çš„å†…å­˜åœ¨å®¢æˆ·æœºçš„å†…æ ¸é‡Œé¢ï¼Œå¦‚ä½•å‘ŠçŸ¥qemuæ¥è®¿é—®è¿™æ®µå†…å­˜å‘¢ï¼Ÿ</p><p>åˆ«å¿˜äº†ï¼Œqemuæ¨¡æ‹Ÿå‡ºæ¥çš„virtio block deviceåªæ˜¯ä¸€ä¸ªPCIè®¾å¤‡ã€‚å¯¹äºå®¢æˆ·æœºæ¥è®²ï¼Œè¿™æ˜¯ä¸€ä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„æ–¹å¼å‘ŠçŸ¥å¤–éƒ¨è®¾å¤‡ï¼Œè¿™å°±æ˜¯ä»£ç ä¸­vp_iowrite16çš„ä½œç”¨ã€‚å®ƒä¼šè°ƒç”¨ä¸“é—¨ç»™å¤–éƒ¨è®¾å¤‡å‘é€æŒ‡ä»¤çš„å‡½æ•°iowriteï¼Œå‘Šè¯‰å¤–éƒ¨çš„PCIè®¾å¤‡ã€‚</p><p>å‘ŠçŸ¥çš„æœ‰ä¸‰ä¸ªåœ°å€virtqueue_get_desc_addrã€virtqueue_get_avail_addrï¼Œvirtqueue_get_used_addrã€‚ä»å®¢æˆ·æœºè§’åº¦æ¥çœ‹ï¼Œè¿™é‡Œé¢çš„åœ°å€éƒ½æ˜¯ç‰©ç†åœ°å€ï¼Œä¹Ÿå³GPAï¼ˆGuest Physical Addressï¼‰ã€‚å› ä¸ºåªæœ‰ç‰©ç†åœ°å€æ‰æ˜¯å®¢æˆ·æœºå’Œqemuç¨‹åºéƒ½è®¤å¯çš„åœ°å€ï¼Œæœ¬æ¥å®¢æˆ·æœºçš„ç‰©ç†å†…å­˜ä¹Ÿæ˜¯qemuæ¨¡æ‹Ÿå‡ºæ¥çš„ã€‚</p><p>åœ¨qemuä¸­ï¼Œå¯¹PCIæ€»çº¿æ·»åŠ ä¸€ä¸ªè®¾å¤‡çš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨virtio_pci_device_pluggedã€‚</p><pre><code>static void virtio_pci_device_plugged(DeviceState *d, Error **errp)
{
    VirtIOPCIProxy *proxy = VIRTIO_PCI(d);
......
    memory_region_init_io(&amp;proxy-&gt;bar, OBJECT(proxy),
                              &amp;virtio_pci_config_ops,
                              proxy, &quot;virtio-pci&quot;, size);
......
}

static const MemoryRegionOps virtio_pci_config_ops = {
    .read = virtio_pci_config_read,
    .write = virtio_pci_config_write,
    .impl = {
        .min_access_size = 1,
        .max_access_size = 4,
    },
    .endianness = DEVICE_LITTLE_ENDIAN,
};
</code></pre><p>åœ¨è¿™é‡Œé¢ï¼Œå¯¹äºè¿™ä¸ªåŠ è½½çš„è®¾å¤‡è¿›è¡ŒI/Oæ“ä½œï¼Œä¼šæ˜ å°„åˆ°è¯»å†™æŸä¸€å—å†…å­˜ç©ºé—´ï¼Œå¯¹åº”çš„æ“ä½œä¸ºvirtio_pci_config_opsï¼Œä¹Ÿå³å†™å…¥è¿™å—å†…å­˜ç©ºé—´ï¼Œè¿™å°±ç›¸å½“äºå¯¹äºè¿™ä¸ªPCIè®¾å¤‡è¿›è¡ŒæŸç§é…ç½®ã€‚</p><p>å¯¹PCIè®¾å¤‡è¿›è¡Œé…ç½®çš„æ—¶å€™ï¼Œä¼šæœ‰è¿™æ ·çš„è°ƒç”¨é“¾ï¼švirtio_pci_config_write-&gt;virtio_ioport_write-&gt;virtio_queue_set_addrã€‚è®¾ç½®virtioçš„queueçš„åœ°å€æ˜¯ä¸€é¡¹å¾ˆé‡è¦çš„æ“ä½œã€‚</p><pre><code>void virtio_queue_set_addr(VirtIODevice *vdev, int n, hwaddr addr)
{
    vdev-&gt;vq[n].vring.desc = addr;
    virtio_queue_update_rings(vdev, n);
}
</code></pre><p>ä»è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œqemuåç«¯çš„VirtIODeviceçš„VirtQueueçš„vringçš„åœ°å€ï¼Œè¢«è®¾ç½®æˆäº†åˆšæ‰ç»™é˜Ÿåˆ—åˆ†é…çš„å†…å­˜çš„GPAã€‚</p><p><img src="https://static001.geekbang.org/resource/image/25/d0/2572f8b1e75b9eaab6560866fcb31fd0.jpg?wh=5158*4690" alt=""></p><p>æ¥ç€ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªé˜Ÿåˆ—çš„æ ¼å¼ã€‚</p><p><img src="https://static001.geekbang.org/resource/image/49/db/49414d5acc81933b66410bbba102b0db.jpg?wh=1546*1303" alt=""></p><pre><code>/* Virtio ring descriptors: 16 bytes.  These can chain together via &quot;next&quot;. */
struct vring_desc {
	/* Address (guest-physical). */
	__virtio64 addr;
	/* Length. */
	__virtio32 len;
	/* The flags as indicated above. */
	__virtio16 flags;
	/* We chain unused descriptors via this, too */
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[];
};

/* u32 is used here for ids for padding reasons. */
struct vring_used_elem {
	/* Index of start of used descriptor chain. */
	__virtio32 id;
	/* Total length of the descriptor chain which was used (written to) */
	__virtio32 len;
};

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	struct vring_used_elem ring[];
};

struct vring {
	unsigned int num;

	struct vring_desc *desc;

	struct vring_avail *avail;

	struct vring_used *used;
};
</code></pre><p>vringåŒ…å«ä¸‰ä¸ªæˆå‘˜ï¼š</p><ul>
<li>vring_descæŒ‡å‘åˆ†é…çš„å†…å­˜å—ï¼Œç”¨äºå­˜æ”¾å®¢æˆ·æœºå’Œqemuä¹‹é—´ä¼ è¾“çš„æ•°æ®ã€‚</li>
<li>avail-&gt;ring[]æ˜¯å‘é€ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘éœ€è¦æ¥æ”¶ç«¯å¤„ç†çš„vring_descã€‚</li>
<li>used-&gt;ring[]æ˜¯æ¥æ”¶ç«¯ç»´æŠ¤çš„ç¯å½¢é˜Ÿåˆ—ï¼ŒæŒ‡å‘è‡ªå·±å·²ç»å¤„ç†è¿‡äº†çš„vring_descã€‚</li>
</ul><h2>æ•°æ®å†™å…¥çš„æµç¨‹</h2><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥çœ‹ï¼ŒçœŸçš„å†™å…¥ä¸€ä¸ªæ•°æ®çš„æ—¶å€™ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆã€‚</p><p>æŒ‰ç…§ä¸Šé¢virtioé©±åŠ¨åˆå§‹åŒ–çš„æ—¶å€™çš„é€»è¾‘ï¼Œblk_mq_make_requestä¼šè¢«è°ƒç”¨ã€‚è¿™ä¸ªå‡½æ•°æ¯”è¾ƒå¤æ‚ï¼Œä¼šåˆ†æˆå¤šä¸ªåˆ†æ”¯ï¼Œä½†æ˜¯æœ€ç»ˆéƒ½ä¼šè°ƒç”¨åˆ°request_queueçš„virtio_mq_opsçš„queue_rqå‡½æ•°ã€‚</p><pre><code>struct request_queue *q = rq-&gt;q;
q-&gt;mq_ops-&gt;queue_rq(hctx, &amp;bd);

static const struct blk_mq_ops virtio_mq_ops = {
	.queue_rq	= virtio_queue_rq,
	.complete	= virtblk_request_done,
	.init_request	= virtblk_init_request,
	.map_queues	= virtblk_map_queues,
};
</code></pre><p>æ ¹æ®virtio_mq_opsçš„å®šä¹‰ï¼Œæˆ‘ä»¬ç°åœ¨è¦è°ƒç”¨virtio_queue_rqã€‚</p><pre><code>static blk_status_t virtio_queue_rq(struct blk_mq_hw_ctx *hctx,
			   const struct blk_mq_queue_data *bd)
{
	struct virtio_blk *vblk = hctx-&gt;queue-&gt;queuedata;
	struct request *req = bd-&gt;rq;
	struct virtblk_req *vbr = blk_mq_rq_to_pdu(req);
......
	err = virtblk_add_req(vblk-&gt;vqs[qid].vq, vbr, vbr-&gt;sg, num);
......
	if (notify)
		virtqueue_notify(vblk-&gt;vqs[qid].vq);
	return BLK_STS_OK;
}
</code></pre><p>åœ¨virtio_queue_rqä¸­ï¼Œæˆ‘ä»¬ä¼šå°†è¯·æ±‚å†™å…¥çš„æ•°æ®ï¼Œé€šè¿‡virtblk_add_reqæ”¾å…¥struct virtqueueã€‚</p><p>å› æ­¤ï¼Œæ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk_add_req-&gt;virtqueue_add_sgs-&gt;virtqueue_addã€‚</p><pre><code>static inline int virtqueue_add(struct virtqueue *_vq,
				struct scatterlist *sgs[],
				unsigned int total_sg,
				unsigned int out_sgs,
				unsigned int in_sgs,
				void *data,
				void *ctx,
				gfp_t gfp)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
	struct scatterlist *sg;
	struct vring_desc *desc;
	unsigned int i, n, avail, descs_used, uninitialized_var(prev), err_idx;
	int head;
	bool indirect;
......
	head = vq-&gt;free_head;

	indirect = false;
	desc = vq-&gt;vring.desc;
	i = head;
	descs_used = total_sg;

	for (n = 0; n &lt; out_sgs; n++) {
		for (sg = sgs[n]; sg; sg = sg_next(sg)) {
			dma_addr_t addr = vring_map_one_sg(vq, sg, DMA_TO_DEVICE);
......
			desc[i].flags = cpu_to_virtio16(_vq-&gt;vdev, VRING_DESC_F_NEXT);
			desc[i].addr = cpu_to_virtio64(_vq-&gt;vdev, addr);
			desc[i].len = cpu_to_virtio32(_vq-&gt;vdev, sg-&gt;length);
			prev = i;
			i = virtio16_to_cpu(_vq-&gt;vdev, desc[i].next);
		}
	}

	/* Last one doesn't continue. */
	desc[prev].flags &amp;= cpu_to_virtio16(_vq-&gt;vdev, ~VRING_DESC_F_NEXT);

	/* We're using some buffers from the free list. */
	vq-&gt;vq.num_free -= descs_used;

	/* Update free pointer */
	vq-&gt;free_head = i;

	/* Store token and indirect buffer state. */
	vq-&gt;desc_state[head].data = data;

	/* Put entry in available array (but don't update avail-&gt;idx until they do sync). */
	avail = vq-&gt;avail_idx_shadow &amp; (vq-&gt;vring.num - 1);
	vq-&gt;vring.avail-&gt;ring[avail] = cpu_to_virtio16(_vq-&gt;vdev, head);

	/* Descriptors and available array need to be set before we expose the new available array entries. */
	virtio_wmb(vq-&gt;weak_barriers);
	vq-&gt;avail_idx_shadow++;
	vq-&gt;vring.avail-&gt;idx = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_idx_shadow);
	vq-&gt;num_added++;
......
	return 0;
}
</code></pre><p>åœ¨virtqueue_addå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°ï¼Œfree_headæŒ‡å‘çš„æ•´ä¸ªå†…å­˜å—ç©ºé—²é“¾è¡¨çš„èµ·å§‹ä½ç½®ï¼Œç”¨headå˜é‡è®°ä½è¿™ä¸ªèµ·å§‹ä½ç½®ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œiä¹ŸæŒ‡å‘è¿™ä¸ªèµ·å§‹ä½ç½®ï¼Œç„¶åæ˜¯ä¸€ä¸ªforå¾ªç¯ï¼Œå°†æ•°æ®æ”¾åˆ°å†…å­˜å—é‡Œé¢ï¼Œæ”¾çš„è¿‡ç¨‹ä¸­ï¼Œnextä¸æ–­æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œè¿™æ ·ç©ºé—²çš„å†…å­˜å—è¢«ä¸æ–­çš„å ç”¨ã€‚ç­‰æ‰€æœ‰çš„å†™å…¥éƒ½ç»“æŸäº†ï¼Œiå°±ä¼šæŒ‡å‘è¿™æ¬¡å­˜æ”¾çš„å†…å­˜å—çš„ä¸‹ä¸€ä¸ªç©ºé—²ä½ç½®ï¼Œç„¶åfree_headå°±æŒ‡å‘iï¼Œå› ä¸ºå‰é¢çš„éƒ½å¡«æ»¡äº†ã€‚</p><p>è‡³æ­¤ï¼Œä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ï¼Œå°±æ˜¯è¿™æ¬¡å†™å…¥çš„å…¨éƒ¨æ•°æ®ã€‚</p><p>äºæ˜¯ï¼Œåœ¨vringçš„availå˜é‡ä¸­ï¼Œåœ¨ring[]æ•°ç»„ä¸­åˆ†é…æ–°çš„ä¸€é¡¹ï¼Œåœ¨availçš„ä½ç½®ï¼Œavailçš„è®¡ç®—æ˜¯avail_idx_shadow &amp; (vq-&gt;vring.num - 1)ï¼Œå…¶ä¸­ï¼Œavail_idx_shadowæ˜¯ä¸Šä¸€æ¬¡çš„availçš„ä½ç½®ã€‚è¿™é‡Œå¦‚æœè¶…è¿‡äº†ring[]æ•°ç»„çš„ä¸‹æ ‡ï¼Œåˆ™é‡æ–°è·³åˆ°èµ·å§‹ä½ç½®ï¼Œå°±è¯´æ˜æ˜¯ä¸€ä¸ªç¯ã€‚è¿™æ¬¡åˆ†é…çš„æ–°çš„availçš„ä½ç½®å°±å­˜æ”¾æ–°å†™å…¥çš„ä»headåˆ°iä¹‹é—´çš„å†…å­˜å—ã€‚ç„¶åæ˜¯avail_idx_shadow++ï¼Œè¿™è¯´æ˜è¿™ä¸€å—å†…å­˜å¯ä»¥è¢«æ¥æ”¶æ–¹è¯»å–äº†ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å›åˆ°virtio_queue_rqï¼Œè°ƒç”¨virtqueue_notifyé€šçŸ¥æ¥æ”¶æ–¹ã€‚è€Œvirtqueue_notifyä¼šè°ƒç”¨vp_notifyã€‚</p><pre><code>bool vp_notify(struct virtqueue *vq)
{
	/* we write the queue's selector into the notification register to
	 * signal the other end */
	iowrite16(vq-&gt;index, (void __iomem *)vq-&gt;priv);
	return true;
}
</code></pre><p>ç„¶åï¼Œæˆ‘ä»¬å†™å…¥ä¸€ä¸ªI/Oä¼šè§¦å‘VM exitã€‚æˆ‘ä»¬åœ¨è§£æCPUçš„æ—¶å€™çœ‹åˆ°è¿‡è¿™ä¸ªé€»è¾‘ã€‚</p><pre><code>int kvm_cpu_exec(CPUState *cpu)
{
    struct kvm_run *run = cpu-&gt;kvm_run;
    int ret, run_ret;
......
    run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);
......
    switch (run-&gt;exit_reason) {
        case KVM_EXIT_IO:
            DPRINTF(&quot;handle_io\n&quot;);
            /* Called outside BQL */
            kvm_handle_io(run-&gt;io.port, attrs,
                          (uint8_t *)run + run-&gt;io.data_offset,
                          run-&gt;io.direction,
                          run-&gt;io.size,
                          run-&gt;io.count);
            ret = 0;
            break;
    }
......
}
</code></pre><p>è¿™æ¬¡å†™å…¥çš„ä¹Ÿæ˜¯ä¸€ä¸ªI/Oçš„å†…å­˜ç©ºé—´ï¼ŒåŒæ ·ä¼šè§¦å‘virtio_ioport_writeï¼Œè¿™æ¬¡ä¼šè°ƒç”¨virtio_queue_notifyã€‚</p><pre><code>void virtio_queue_notify(VirtIODevice *vdev, int n)
{
    VirtQueue *vq = &amp;vdev-&gt;vq[n];
......
    if (vq-&gt;handle_aio_output) {
        event_notifier_set(&amp;vq-&gt;host_notifier);
    } else if (vq-&gt;handle_output) {
        vq-&gt;handle_output(vdev, vq);
    }
}
</code></pre><p>virtio_queue_notifyä¼šè°ƒç”¨VirtQueueçš„handle_outputå‡½æ•°ï¼Œå‰é¢æˆ‘ä»¬å·²ç»è®¾ç½®è¿‡è¿™ä¸ªå‡½æ•°äº†ï¼Œæ˜¯virtio_blk_handle_outputã€‚</p><p>æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio_blk_handle_output-&gt;virtio_blk_handle_output_do-&gt;virtio_blk_handle_vqã€‚</p><pre><code>bool virtio_blk_handle_vq(VirtIOBlock *s, VirtQueue *vq)
{
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    bool progress = false;
......
    do {
        virtio_queue_set_notification(vq, 0);

        while ((req = virtio_blk_get_request(s, vq))) {
            progress = true;
            if (virtio_blk_handle_request(req, &amp;mrb)) {
                virtqueue_detach_element(req-&gt;vq, &amp;req-&gt;elem, 0);
                virtio_blk_free_request(req);
                break;
            }
        }

        virtio_queue_set_notification(vq, 1);
    } while (!virtio_queue_empty(vq));

    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s-&gt;blk, &amp;mrb);
    }
......
    return progress;
}
</code></pre><p>åœ¨virtio_blk_handle_vqä¸­ï¼Œæœ‰ä¸€ä¸ªwhileå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­è°ƒç”¨å‡½æ•°virtio_blk_get_requestä»vqä¸­å–å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio_blk_handle_requestå¤„ç†ä»vqä¸­å–å‡ºçš„è¯·æ±‚ã€‚</p><p>æˆ‘ä»¬å…ˆæ¥çœ‹virtio_blk_get_requestã€‚</p><pre><code>static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s, VirtQueue *vq)
{
    VirtIOBlockReq *req = virtqueue_pop(vq, sizeof(VirtIOBlockReq));

    if (req) {
        virtio_blk_init_request(s, vq, req);
    }
    return req;
}

void *virtqueue_pop(VirtQueue *vq, size_t sz)
{
    unsigned int i, head, max;
    VRingMemoryRegionCaches *caches;
    MemoryRegionCache *desc_cache;
    int64_t len;
    VirtIODevice *vdev = vq-&gt;vdev;
    VirtQueueElement *elem = NULL;
    unsigned out_num, in_num, elem_entries;
    hwaddr addr[VIRTQUEUE_MAX_SIZE];
    struct iovec iov[VIRTQUEUE_MAX_SIZE];
    VRingDesc desc;
    int rc;
......
    /* When we start there are none of either input nor output. */
    out_num = in_num = elem_entries = 0;

    max = vq-&gt;vring.num;

    i = head;

    caches = vring_get_region_caches(vq);
    desc_cache = &amp;caches-&gt;desc;
    vring_desc_read(vdev, &amp;desc, desc_cache, i);
......
    /* Collect all the descriptors */
    do {
        bool map_ok;

        if (desc.flags &amp; VRING_DESC_F_WRITE) {
            map_ok = virtqueue_map_desc(vdev, &amp;in_num, addr + out_num,
                                        iov + out_num,
                                        VIRTQUEUE_MAX_SIZE - out_num, true,
                                        desc.addr, desc.len);
        } else {
            map_ok = virtqueue_map_desc(vdev, &amp;out_num, addr, iov,
                                        VIRTQUEUE_MAX_SIZE, false,
                                        desc.addr, desc.len);
        }
......
        rc = virtqueue_read_next_desc(vdev, &amp;desc, desc_cache, max, &amp;i);
    } while (rc == VIRTQUEUE_READ_DESC_MORE);
......
    /* Now copy what we have collected and mapped */
    elem = virtqueue_alloc_element(sz, out_num, in_num);
    elem-&gt;index = head;
    for (i = 0; i &lt; out_num; i++) {
        elem-&gt;out_addr[i] = addr[i];
        elem-&gt;out_sg[i] = iov[i];
    }
    for (i = 0; i &lt; in_num; i++) {
        elem-&gt;in_addr[i] = addr[out_num + i];
        elem-&gt;in_sg[i] = iov[out_num + i];
    }

    vq-&gt;inuse++;
......
    return elem;
}
</code></pre><p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtio_blk_get_requestä¼šè°ƒç”¨virtqueue_popã€‚åœ¨è¿™é‡Œé¢ï¼Œæˆ‘ä»¬èƒ½çœ‹åˆ°å¯¹äºvringçš„æ“ä½œï¼Œä¹Ÿå³ä»è¿™é‡Œé¢å°†å®¢æˆ·æœºé‡Œé¢å†™å…¥çš„æ•°æ®è¯»å–å‡ºæ¥ï¼Œæ”¾åˆ°VirtIOBlockReqç»“æ„ä¸­ã€‚</p><p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬å°±è¦è°ƒç”¨virtio_blk_handle_requestå¤„ç†è¿™äº›æ•°æ®ã€‚æ‰€ä»¥æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtio_blk_handle_request-&gt;virtio_blk_submit_multireq-&gt;submit_requestsã€‚</p><pre><code>static inline void submit_requests(BlockBackend *blk, MultiReqBuffer *mrb,int start, int num_reqs, int niov)
{
    QEMUIOVector *qiov = &amp;mrb-&gt;reqs[start]-&gt;qiov;
    int64_t sector_num = mrb-&gt;reqs[start]-&gt;sector_num;
    bool is_write = mrb-&gt;is_write;

    if (num_reqs &gt; 1) {
        int i;
        struct iovec *tmp_iov = qiov-&gt;iov;
        int tmp_niov = qiov-&gt;niov;
        qemu_iovec_init(qiov, niov);

        for (i = 0; i &lt; tmp_niov; i++) {
            qemu_iovec_add(qiov, tmp_iov[i].iov_base, tmp_iov[i].iov_len);
        }

        for (i = start + 1; i &lt; start + num_reqs; i++) {
            qemu_iovec_concat(qiov, &amp;mrb-&gt;reqs[i]-&gt;qiov, 0,
                              mrb-&gt;reqs[i]-&gt;qiov.size);
            mrb-&gt;reqs[i - 1]-&gt;mr_next = mrb-&gt;reqs[i];
        }

        block_acct_merge_done(blk_get_stats(blk),
                              is_write ? BLOCK_ACCT_WRITE : BLOCK_ACCT_READ,
                              num_reqs - 1);
    }

    if (is_write) {
        blk_aio_pwritev(blk, sector_num &lt;&lt; BDRV_SECTOR_BITS, qiov, 0,
                        virtio_blk_rw_complete, mrb-&gt;reqs[start]);
    } else {
        blk_aio_preadv(blk, sector_num &lt;&lt; BDRV_SECTOR_BITS, qiov, 0,
                       virtio_blk_rw_complete, mrb-&gt;reqs[start]);
    }
}
</code></pre><p>åœ¨submit_requestsä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†BlockBackendã€‚è¿™æ˜¯åœ¨qemuå¯åŠ¨çš„æ—¶å€™ï¼Œæ‰“å¼€qcow2æ–‡ä»¶çš„æ—¶å€™ç”Ÿæˆçš„ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥ç”¨å®ƒæ¥å†™å…¥æ–‡ä»¶äº†ï¼Œè°ƒç”¨çš„æ˜¯blk_aio_pwritevã€‚</p><pre><code>BlockAIOCB *blk_aio_pwritev(BlockBackend *blk, int64_t offset,
                            QEMUIOVector *qiov, BdrvRequestFlags flags,
                            BlockCompletionFunc *cb, void *opaque)
{
    return blk_aio_prwv(blk, offset, qiov-&gt;size, qiov,
                        blk_aio_write_entry, flags, cb, opaque);
}

static BlockAIOCB *blk_aio_prwv(BlockBackend *blk, int64_t offset, int bytes,
                                void *iobuf, CoroutineEntry co_entry,
                                BdrvRequestFlags flags,
                                BlockCompletionFunc *cb, void *opaque)
{
    BlkAioEmAIOCB *acb;
    Coroutine *co;
    acb = blk_aio_get(&amp;blk_aio_em_aiocb_info, blk, cb, opaque);
    acb-&gt;rwco = (BlkRwCo) {
        .blk    = blk,
        .offset = offset,
        .iobuf  = iobuf,
        .flags  = flags,
        .ret    = NOT_DONE,
    };
    acb-&gt;bytes = bytes;
    acb-&gt;has_returned = false;

    co = qemu_coroutine_create(co_entry, acb);
    bdrv_coroutine_enter(blk_bs(blk), co);

    acb-&gt;has_returned = true;
    return &amp;acb-&gt;common;
}
</code></pre><p>åœ¨blk_aio_pwritevä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°ï¼Œåˆæ˜¯åˆ›å»ºäº†ä¸€ä¸ªåç¨‹æ¥è¿›è¡Œå†™å…¥ã€‚å†™å…¥å®Œæ¯•ä¹‹åè°ƒç”¨virtio_blk_rw_complete-&gt;virtio_blk_req_completeã€‚</p><pre><code>static void virtio_blk_req_complete(VirtIOBlockReq *req, unsigned char status)
{
    VirtIOBlock *s = req-&gt;dev;
    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    trace_virtio_blk_req_complete(vdev, req, status);

    stb_p(&amp;req-&gt;in-&gt;status, status);
    virtqueue_push(req-&gt;vq, &amp;req-&gt;elem, req-&gt;in_len);
    virtio_notify(vdev, req-&gt;vq);
}
</code></pre><p>åœ¨virtio_blk_req_completeä¸­ï¼Œæˆ‘ä»¬å…ˆæ˜¯è°ƒç”¨virtqueue_pushï¼Œæ›´æ–°vringä¸­usedå˜é‡ï¼Œè¡¨ç¤ºè¿™éƒ¨åˆ†å·²ç»å†™å…¥å®Œæ¯•ï¼Œç©ºé—´å¯ä»¥å›æ”¶åˆ©ç”¨äº†ã€‚ä½†æ˜¯ï¼Œè¿™éƒ¨åˆ†çš„æ”¹å˜ä»…ä»…æ”¹å˜äº†qemuåç«¯çš„vringï¼Œæˆ‘ä»¬è¿˜éœ€è¦é€šçŸ¥å®¢æˆ·æœºä¸­virtioå‰ç«¯çš„vringçš„å€¼ï¼Œå› è€Œè¦è°ƒç”¨virtio_notifyã€‚virtio_notifyä¼šè°ƒç”¨virtio_irqå‘é€ä¸€ä¸ªä¸­æ–­ã€‚</p><p>è¿˜è®°å¾—å’±ä»¬å‰é¢æ³¨å†Œè¿‡ä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptå—ï¼Ÿå®ƒå°±æ˜¯å¹²è¿™ä¸ªäº‹æƒ…çš„ã€‚</p><pre><code>static irqreturn_t vp_interrupt(int irq, void *opaque)
{
	struct virtio_pci_device *vp_dev = opaque;
	u8 isr;

	/* reading the ISR has the effect of also clearing it so it's very
	 * important to save off the value. */
	isr = ioread8(vp_dev-&gt;isr);

	/* Configuration change?  Tell driver if it wants to know. */
	if (isr &amp; VIRTIO_PCI_ISR_CONFIG)
		vp_config_changed(irq, opaque);

	return vp_vring_interrupt(irq, opaque);
}
</code></pre><p>å°±åƒå‰é¢è¯´çš„ä¸€æ ·vp_interruptè¿™ä¸ªä¸­æ–­å¤„ç†å‡½æ•°ï¼Œä¸€æ˜¯å¤„ç†é…ç½®å˜åŒ–ï¼ŒäºŒæ˜¯å¤„ç†I/Oç»“æŸã€‚ç¬¬äºŒç§çš„è°ƒç”¨é“¾ä¸ºï¼švp_interrupt-&gt;vp_vring_interrupt-&gt;vring_interruptã€‚</p><pre><code>irqreturn_t vring_interrupt(int irq, void *_vq)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
......
	if (vq-&gt;vq.callback)
		vq-&gt;vq.callback(&amp;vq-&gt;vq);

	return IRQ_HANDLED;
}
</code></pre><p>åœ¨vring_interruptä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨callbackå‡½æ•°ï¼Œè¿™ä¸ªä¹Ÿæ˜¯åœ¨å‰é¢æ³¨å†Œè¿‡çš„ï¼Œæ˜¯virtblk_doneã€‚</p><p>æ¥ä¸‹æ¥çš„è°ƒç”¨é“¾ä¸ºï¼švirtblk_done-&gt;virtqueue_get_buf-&gt;virtqueue_get_buf_ctxã€‚</p><pre><code>void *virtqueue_get_buf_ctx(struct virtqueue *_vq, unsigned int *len,
			    void **ctx)
{
	struct vring_virtqueue *vq = to_vvq(_vq);
	void *ret;
	unsigned int i;
	u16 last_used;
......
	last_used = (vq-&gt;last_used_idx &amp; (vq-&gt;vring.num - 1));
	i = virtio32_to_cpu(_vq-&gt;vdev, vq-&gt;vring.used-&gt;ring[last_used].id);
	*len = virtio32_to_cpu(_vq-&gt;vdev, vq-&gt;vring.used-&gt;ring[last_used].len);
......
	/* detach_buf clears data, so grab it now. */
	ret = vq-&gt;desc_state[i].data;
	detach_buf(vq, i, ctx);
	vq-&gt;last_used_idx++;
......
	return ret;
}
</code></pre><p>åœ¨virtqueue_get_buf_ctxä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œvirtioå‰ç«¯çš„vringä¸­çš„last_used_idxåŠ ä¸€ï¼Œè¯´æ˜è¿™å—æ•°æ®qemuåç«¯å·²ç»æ¶ˆè´¹å®Œæ¯•ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡detach_bufå°†å…¶æ”¾å…¥ç©ºé—²é˜Ÿåˆ—ä¸­ï¼Œç•™ç»™ä»¥åçš„å†™å…¥è¯·æ±‚ä½¿ç”¨ã€‚</p><p>è‡³æ­¤ï¼Œæ•´ä¸ªå­˜å‚¨è™šæ‹ŸåŒ–çš„å†™å…¥æµç¨‹æ‰å…¨éƒ¨å®Œæˆã€‚</p><h2>æ€»ç»“æ—¶åˆ»</h2><p>ä¸‹é¢æˆ‘ä»¬æ¥æ€»ç»“ä¸€ä¸‹å­˜å‚¨è™šæ‹ŸåŒ–çš„åœºæ™¯ä¸‹ï¼Œæ•´ä¸ªå†™å…¥çš„è¿‡ç¨‹ã€‚</p><ul>
<li>åœ¨è™šæ‹Ÿæœºé‡Œé¢ï¼Œåº”ç”¨å±‚è°ƒç”¨writeç³»ç»Ÿè°ƒç”¨å†™å…¥æ–‡ä»¶ã€‚</li>
<li>writeç³»ç»Ÿè°ƒç”¨è¿›å…¥è™šæ‹Ÿæœºé‡Œé¢çš„å†…æ ¸ï¼Œç»è¿‡VFSï¼Œé€šç”¨å—è®¾å¤‡å±‚ï¼ŒI/Oè°ƒåº¦å±‚ï¼Œåˆ°è¾¾å—è®¾å¤‡é©±åŠ¨ã€‚</li>
<li>è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio_blkï¼Œå®ƒå’Œé€šç”¨çš„å—è®¾å¤‡é©±åŠ¨ä¸€æ ·ï¼Œæœ‰ä¸€ä¸ªrequest  queueï¼Œå¦å¤–æœ‰ä¸€ä¸ªå‡½æ•°make_request_fnä¼šè¢«è®¾ç½®ä¸ºblk_mq_make_requestï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºå°†è¯·æ±‚æ”¾å…¥é˜Ÿåˆ—ã€‚</li>
<li>è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨æ˜¯virtio_blkä¼šæ³¨å†Œä¸€ä¸ªä¸­æ–­å¤„ç†å‡½æ•°vp_interruptã€‚å½“qemuå†™å…¥å®Œæˆä¹‹åï¼Œå®ƒä¼šé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„å—è®¾å¤‡é©±åŠ¨ã€‚</li>
<li>blk_mq_make_requestæœ€ç»ˆè°ƒç”¨virtqueue_addï¼Œå°†è¯·æ±‚æ·»åŠ åˆ°ä¼ è¾“é˜Ÿåˆ—virtqueueä¸­ï¼Œç„¶åè°ƒç”¨virtqueue_notifyé€šçŸ¥qemuã€‚</li>
<li>åœ¨qemuä¸­ï¼Œæœ¬æ¥è™šæ‹Ÿæœºæ­£å¤„äºKVM_RUNçš„çŠ¶æ€ï¼Œä¹Ÿå³å¤„äºå®¢æˆ·æœºçŠ¶æ€ã€‚</li>
<li>qemuæ”¶åˆ°é€šçŸ¥åï¼Œé€šè¿‡VM exitæŒ‡ä»¤é€€å‡ºå®¢æˆ·æœºçŠ¶æ€ï¼Œè¿›å…¥å®¿ä¸»æœºçŠ¶æ€ï¼Œæ ¹æ®é€€å‡ºåŸå› ï¼Œå¾—çŸ¥æœ‰I/Oéœ€è¦å¤„ç†ã€‚</li>
<li>qemuè°ƒç”¨virtio_blk_handle_outputï¼Œæœ€ç»ˆè°ƒç”¨virtio_blk_handle_vqã€‚</li>
<li>virtio_blk_handle_vqé‡Œé¢æœ‰ä¸€ä¸ªå¾ªç¯ï¼Œåœ¨å¾ªç¯ä¸­ï¼Œvirtio_blk_get_requestå‡½æ•°ä»ä¼ è¾“é˜Ÿåˆ—ä¸­æ‹¿å‡ºè¯·æ±‚ï¼Œç„¶åè°ƒç”¨virtio_blk_handle_requestå¤„ç†è¯·æ±‚ã€‚</li>
<li>virtio_blk_handle_requestä¼šè°ƒç”¨blk_aio_pwritevï¼Œé€šè¿‡BlockBackendé©±åŠ¨å†™å…¥qcow2æ–‡ä»¶ã€‚</li>
<li>å†™å…¥å®Œæ¯•ä¹‹åï¼Œvirtio_blk_req_completeä¼šè°ƒç”¨virtio_notifyé€šçŸ¥è™šæ‹Ÿæœºé‡Œé¢çš„é©±åŠ¨ã€‚æ•°æ®å†™å…¥å®Œæˆï¼Œåˆšæ‰æ³¨å†Œçš„ä¸­æ–­å¤„ç†å‡½æ•°vp_interruptä¼šæ”¶åˆ°è¿™ä¸ªé€šçŸ¥ã€‚</li>
</ul><p><img src="https://static001.geekbang.org/resource/image/79/0c/79ad143a3149ea36bc80219940d7d00c.jpg?wh=2503*5023" alt=""></p><h2>è¯¾å ‚ç»ƒä¹ </h2><p>è¯·ä½ æ²¿ç€ä»£ç ï¼Œä»”ç»†åˆ†æå¹¶ç‰¢è®°virtqueueçš„ç»“æ„ä»¥åŠå†™å…¥å’Œè¯»å–æ–¹å¼ã€‚è¿™ä¸ªç»“æ„åœ¨ä¸‹é¢çš„ç½‘ç»œä¼ è¾“è¿‡ç¨‹ä¸­ï¼Œè¿˜è¦èµ·å¤§ä½œç”¨ã€‚</p><p>æ¬¢è¿ç•™è¨€å’Œæˆ‘åˆ†äº«ä½ çš„ç–‘æƒ‘å’Œè§è§£ï¼Œä¹Ÿæ¬¢è¿æ”¶è—æœ¬èŠ‚å†…å®¹ï¼Œåå¤ç ”è¯»ã€‚ä½ ä¹Ÿå¯ä»¥æŠŠä»Šå¤©çš„å†…å®¹åˆ†äº«ç»™ä½ çš„æœ‹å‹ï¼Œå’Œä»–ä¸€èµ·å­¦ä¹ å’Œè¿›æ­¥ã€‚</p><p><img src="https://static001.geekbang.org/resource/image/8c/37/8c0a95fa07a8b9a1abfd394479bdd637.jpg?wh=1110*659" alt=""></p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/35/73/46d6dadc.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>æ²¡å¿ƒæ²¡è‚º</span>
  </div>
  <div class="_2_QraFYR_0">æ¯æ¬¡çœ‹åˆ°æ–‡ä¸­è¯´è¿˜è®°å¾—ä»€ä¹ˆä»€ä¹ˆå—ï¼Œæˆ‘å¿ƒé‡Œæ€»æ˜¯é»˜é»˜å›ç­”:ä¸ è®° å¾—ğŸ˜‚</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">ä½œè€…å›å¤: çš„ç¡®ï¼Œä½“ç³»æ¯”è¾ƒå¤æ‚ï¼Œå…³è”æ€§å¾ˆå¼º</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-07-31 18:01:32</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/13/54/0a/9a002ad5.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Adam Lau</span>
  </div>
  <div class="_2_QraFYR_0">å¦ç™½è¯´ï¼Œè¿™æ˜¯æå®¢ä¸ŠæŠ€æœ¯å«é‡æœ€å¥½çš„ä¸“æ äº†ï¼Œå¬ä¸æ‡‚äº†ï¼Œä½†æ˜¯è¡¨ç¤ºæ•¬æ„ã€‚</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">ä½œè€…å›å¤: è°¢è°¢ï¼ŒåŠ æ²¹</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2020-04-17 22:58:15</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/ac/96/46b13896.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>williamcai</span>
  </div>
  <div class="_2_QraFYR_0">è°ƒç”¨é“¾æ¡å¥½é•¿ï¼Œçªç„¶æ¥ä¸ªå›é©¬æªï¼Œä¸€ä¸‹å­æ€åˆ°å¼€å§‹çš„åœ°æ–¹<br></div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-12-23 22:43:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/6e/bd/b83ad32d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>shangyu</span>
  </div>
  <div class="_2_QraFYR_0">è€å¸ˆèƒ½ä¸èƒ½è§£é‡Šä¸‹è¿™ç§ç‰¹æ®Šçš„é©±åŠ¨æ¨¡å¼ä¸ç›´æ¥ç¿»è¯‘writeè¯·æ±‚çš„æ€§èƒ½å·®å¼‚</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-12-23 09:44:34</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/16/b4/94/2796de72.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>è¿½é£ç­çš„äºº</span>
  </div>
  <div class="_2_QraFYR_0">å¥½å¤æ‚é¸­</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2019-11-26 21:35:03</div>
  </div>
</div>
</div>
</li>
</ul>