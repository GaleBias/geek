<audio title="22｜函数：怎么结合多返回值进行错误处理？" src="https://static001.geekbang.org/resource/audio/72/3c/72e60a11eb986a33f102f29e5a54c13c.mp3" controls="controls"></audio> 
<p>你好，我是Tony Bai。</p><p>上一节课，我们开始了Go函数的学习，对Go语言中的函数已经有了基础的了解。那么，今天这节课，我们要再进一步，学习怎么做好函数设计。</p><p>在上节课的函数声明部分，我们提到，多返回值是Go语言函数，区别于其他主流静态编程语言中函数的一个重要特点。同时，它也是Go语言设计者建构Go语言错误处理机制的基础，而错误处理设计也是做函数设计的一个重要环节。</p><p>所以今天这节课，我们将会从Go语言的错误处理机制入手，围绕Go语言错误处理机制的原理、Go错误处理的常见策略，来学习一下如何结合函数的多返回值机制进行错误处理的设计。</p><p>这会让你建立起Go编码的统一错误处理思维，写出更健壮的、让你自己更有信心的Go代码。</p><p>要想做好错误处理设计，我们首先要先来了解Go语言错误设计的基本思路与原理。</p><h2>Go语言是如何进行错误处理的？</h2><p>采用什么错误处理方式，其实是一门编程语言在设计早期就要确定下来的基本机制，它在很大程度上影响着编程语言的语法形式、语言实现的难易程度，以及语言后续的演进方向。</p><p>我们前面已经多次提到，Go语言继承了“先祖”C语言的很多语法特性，在错误处理机制上也不例外，Go语言错误处理机制也是在C语言错误处理机制基础上的再创新。</p><!-- [[[read_end]]] --><p>那么这里，我们依然从源头讲起，先看看前辈C语言的错误处理机制。在C语言中，我们通常用一个类型为整型的函数返回值作为错误状态标识，函数调用者会基于值比较的方式，对这一代表错误状态的返回值进行检视。通常，这个返回值为0，就代表函数调用成功；如果这个返回值是其它值，那就代表函数调用出现错误。也就是说，函数调用者需要根据这个返回值代表的错误状态，来决定后续执行哪条错误处理路径上的代码。</p><p>C语言的这种简单的、<strong>基于错误值比较</strong>的错误处理机制有什么优点呢？</p><p>首先，它让每个开发人员必须显式地去关注和处理每个错误，经过显式错误处理的代码会更健壮，也会让开发人员对这些代码更有信心。</p><p>另外，你也可以发现，这些错误就是普通的值，所以我们不需要用额外的语言机制去处理它们，我们只需利用已有的语言机制，像处理其他普通类型值一样的去处理错误就可以了，这也让代码更容易调试，更容易针对每个错误处理的决策分支进行测试覆盖。C语言错误处理机制的这种简单与显式结合的特征，和Go语言设计哲学十分契合，于是Go语言设计者决定继承C语言这种错误处理机制。</p><p>不过C语言这种错误处理机制也有一些弊端。比如，由于C语言中的函数最多仅支持一个返回值，很多开发者会把这单一的返回值“一值多用”。什么意思呢？就是说，一个返回值，不仅要承载函数要返回给调用者的信息，又要承载函数调用的最终错误状态。比如C标准库中的<code>fprintf</code>函数的返回值就承载了两种含义。在正常情况下，它的返回值表示输出到FILE流中的字符数量，但如果出现错误，这个返回值就变成了一个负数，代表具体的错误值：</p><pre><code class="language-plain">// stdio.h
int fprintf(FILE * restrict stream, const char * restrict format, ...);
</code></pre><p>特别是当返回值为其他类型，比如字符串的时候，我们还很难将它与错误状态融合到一起。这个时候，很多C开发人员要么使用输出参数，承载要返回给调用者的信息，要么自定义一个包含返回信息与错误状态的结构体，作为返回值类型。大家做法不一，就很难形成统一的错误处理策略。</p><p>为了避免这种情况，Go函数增加了<strong>多返回值机制</strong>，来支持错误状态与返回信息的分离，并建议开发者把要返回给调用者的信息和错误状态标识，分别放在不同的返回值中。</p><p>我们继续以上面C语言中的fprintf函数为例，Go标准库中有一个和功能等同的<code>fmt.Fprintf</code>的函数，这个函数就是使用一个独立的表示错误状态的返回值（如下面代码中的err），解决了fprintf函数中错误状态值与返回信息耦合在一起的问题：</p><pre><code class="language-go">// fmt包
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)
</code></pre><p>我们看到，在fmt.Fprintf中，返回值n用来表示写入io.Writer中的字节个数，返回值err表示这个函数调用的最终状态，如果成功，err值就为nil，不成功就为特定的错误值。</p><p>另外我们还可以看到，fmt.Fprintf函数声明中代表错误状态的变量err的类型，并不是一个传统使用的整数类型，而是用了一个名为error的类型。</p><p>虽然，在Go语言中，我们依然可以像传统的C语言那样，用一个整型值来表示错误状态，但<strong>Go语言惯用法</strong>，是使用error这个接口类型表示错误，并且按惯例，我们通常将error类型返回值放在返回值列表的末尾，就像fmt.Fprintf函数声明中那样。</p><p>那么error接口类型究竟如何表示错误？我们又该如何构造一个满足error接口类型的错误值呢？我们继续向下看。</p><h2>error类型与错误值构造</h2><p>error接口是Go原生内置的类型，它的定义如下：</p><pre><code class="language-plain">// $GOROOT/src/builtin/builtin.go
type error interface {
    Error() string
}
</code></pre><p>任何实现了error的Error方法的类型的实例，都可以作为错误值赋值给error接口变量。那这里，问题就来了：<strong>难道为了构造一个错误值，我们还需要自定义一个新类型来实现error接口吗</strong>？</p><p>Go语言的设计者显然也想到了这一点，他们在标准库中提供了两种方便Go开发者构造错误值的方法： <code>errors.New</code>和<code>fmt.Errorf</code>。使用这两种方法，我们可以轻松构造出一个满足error接口的错误值，就像下面代码这样：</p><pre><code class="language-plain">err := errors.New("your first demo error")
errWithCtx = fmt.Errorf("index %d is out of bounds", i)
</code></pre><p>这两种方法实际上返回的是同一个实现了error接口的类型的实例，这个未导出的类型就是<code>errors.errorString</code>，它的定义是这样的：</p><pre><code class="language-plain">// $GOROOT/src/errors/errors.go

type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
</code></pre><p>大多数情况下，使用这两种方法构建的错误值就可以满足我们的需求了。但我们也要看到，虽然这两种构建错误值的方法很方便，但它们给错误处理者提供的错误上下文（Error Context）只限于以字符串形式呈现的信息，也就是Error方法返回的信息。</p><p>但在一些场景下，错误处理者需要从错误值中提取出更多信息，帮助他选择错误处理路径，显然这两种方法就不能满足了。这个时候，我们可以自定义错误类型来满足这一需求。比如：标准库中的net包就定义了一种携带额外错误上下文的错误类型：</p><pre><code class="language-plain">// $GOROOT/src/net/net.go
type OpError struct {
    Op string
    Net string
    Source Addr
    Addr Addr
    Err error
}
</code></pre><p>这样，错误处理者就可以根据这个类型的错误值提供的额外上下文信息，比如Op、Net、Source等，做出错误处理路径的选择，比如下面标准库中的代码：</p><pre><code class="language-plain">// $GOROOT/src/net/http/server.go
func isCommonNetReadError(err error) bool {
    if err == io.EOF {
        return true
    }
    if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() {
        return true
    }
    if oe, ok := err.(*net.OpError); ok &amp;&amp; oe.Op == "read" {
        return true
    }
    return false
}
</code></pre><p>我们看到，上面这段代码利用类型断言，判断error类型变量err的动态类型是否为 *net.OpError或 net.Error。如果err的动态类型是 *net.OpError，那么类型断言就会返回这个动态类型的值（存储在oe中），代码就可以通过判断它的Op字段是否为"read"来判断它是否为CommonNetRead类型的错误。</p><p>不过这里，你不用过多了解类型断言（Type Assertion）到底是什么，你只需要知道通过类型断言，我们可以判断接口类型的动态类型，以及获取它动态类型的值接可以了。后面我们在讲解接口类型的时候还会再细讲。</p><p>那么，使用error类型，而不是传统意义上的整型或其他类型作为错误类型，有什么好处呢？至少有这三点好处：</p><p><strong>第一点：统一了错误类型。</strong></p><p>如果不同开发者的代码、不同项目中的代码，甚至标准库中的代码，都统一以error接口变量的形式呈现错误类型，就能在提升代码可读性的同时，还更容易形成统一的错误处理策略。这个我们下面会细讲。</p><p><strong>第二点：错误是值。</strong></p><p>我们构造的错误都是值，也就是说，即便赋值给error这个接口类型变量，我们也可以像整型值那样对错误做“==”和“!=”的逻辑比较，函数调用者检视错误时的体验保持不变。</p><p><strong>第三点：易扩展，支持自定义错误上下文。</strong></p><p>虽然错误以error接口变量的形式统一呈现，但我们很容易通过自定义错误类型来扩展我们的错误上下文，就像前面的Go标准库的OpError类型那样。</p><p>error接口是错误值的提供者与错误值的检视者之间的契约。error接口的实现者负责提供错误上下文，供负责错误处理的代码使用。这种错误具体上下文与作为错误值类型的error接口类型的解耦，也体现了Go组合设计哲学中“正交”的理念。</p><p>到这里，我们已经基本了解了Go错误处理机制、统一的错误值类型，以及错误值构造方法。在这些基础上，我们可以再进一步，学习Go语言的几种错误处理的惯用策略，学习这些策略将有助于我们提升函数错误处理设计的能力。</p><h2>策略一：透明错误处理策略</h2><p>简单来说，Go语言中的错误处理，就是根据函数/方法返回的error类型变量中携带的错误值信息做决策，并选择后续代码执行路径的过程。</p><p>这样，最简单的错误策略莫过于完全不关心返回错误值携带的具体上下文信息，只要发生错误就进入唯一的错误处理执行路径，比如下面这段代码：</p><pre><code class="language-plain">err := doSomething()
if err != nil {
    // 不关心err变量底层错误值所携带的具体上下文信息
    // 执行简单错误处理逻辑并返回
    ... ...
    return err
}
</code></pre><p>这也是Go语言中<strong>最常见的错误处理策略</strong>，80%以上的Go错误处理情形都可以归类到这种策略下。在这种策略下，由于错误处理方并不关心错误值的上下文，所以错误值的构造方（如上面的函数<code>doSomething</code>）可以直接使用Go标准库提供的两个基本错误值构造方法<code>errors.New</code>和<code>fmt.Errorf</code>来构造错误值，就像下面这样：</p><pre><code class="language-plain">func doSomething(...) error {
    ... ...
    return errors.New("some error occurred")
}
</code></pre><p>这样构造出的错误值代表的上下文信息，对错误处理方是透明的，因此这种策略称为<strong>“透明错误处理策略”</strong>。在错误处理方不关心错误值上下文的前提下，透明错误处理策略能最大程度地减少错误处理方与错误值构造方之间的耦合关系。</p><h2>策略二：“哨兵”错误处理策略</h2><p>当错误处理方不能只根据“透明的错误值”就做出错误处理路径选取的情况下，错误处理方会尝试对返回的错误值进行检视，于是就有可能出现下面代码中的<strong>反模式</strong>：</p><pre><code class="language-plain">data, err := b.Peek(1)
if err != nil {
    switch err.Error() {
    case "bufio: negative count":
        // ... ...
        return
    case "bufio: buffer full":
        // ... ...
        return
    case "bufio: invalid use of UnreadByte":
        // ... ...
        return
    default:
        // ... ...
        return
    }
}
</code></pre><p>简单来说，反模式就是，错误处理方以透明错误值所能提供的唯一上下文信息（描述错误的字符串），作为错误处理路径选择的依据。但这种“反模式”会造成严重的<strong>隐式耦合</strong>。这也就意味着，错误值构造方不经意间的一次错误描述字符串的改动，都会造成错误处理方处理行为的变化，并且这种通过字符串比较的方式，对错误值进行检视的性能也很差。</p><p>那这有什么办法吗？Go标准库采用了定义导出的（Exported）“哨兵”错误值的方式，来辅助错误处理方检视（inspect）错误值并做出错误处理分支的决策，比如下面的bufio包中定义的“哨兵错误”：</p><pre><code class="language-plain">// $GOROOT/src/bufio/bufio.go
var (
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")
    ErrBufferFull        = errors.New("bufio: buffer full")
    ErrNegativeCount     = errors.New("bufio: negative count")
)
</code></pre><p>下面的代码片段利用了上面的哨兵错误，进行错误处理分支的决策：</p><pre><code class="language-plain">data, err := b.Peek(1)
if err != nil {
    switch err {
    case bufio.ErrNegativeCount:
        // ... ...
        return
    case bufio.ErrBufferFull:
        // ... ...
        return
    case bufio.ErrInvalidUnreadByte:
        // ... ...
        return
    default:
        // ... ...
        return
    }
}
</code></pre><p>你可以看到，一般“哨兵”错误值变量以ErrXXX格式命名。和透明错误策略相比，“哨兵”策略让错误处理方在有检视错误值的需求时候，可以“有的放矢”。</p><p>不过，对于API的开发者而言，暴露“哨兵”错误值也意味着这些错误值和包的公共函数/方法一起成为了API的一部分。一旦发布出去，开发者就要对它进行很好的维护。而“哨兵”错误值也让使用这些值的错误处理方对它产生了依赖。</p><p>从Go 1.13版本开始，标准库errors包提供了Is函数用于错误处理方对错误值的检视。Is函数类似于把一个error类型变量与“哨兵”错误值进行比较，比如下面代码：</p><pre><code class="language-plain">// 类似 if err == ErrOutOfBounds{ … }
if errors.Is(err, ErrOutOfBounds) {
    // 越界的错误处理
}
</code></pre><p>不同的是，如果error类型变量的底层错误值是一个包装错误（Wrapped Error），errors.Is方法会沿着该包装错误所在错误链（Error Chain)，与链上所有被包装的错误（Wrapped Error）进行比较，直至找到一个匹配的错误为止。下面是Is函数应用的一个例子：</p><pre><code class="language-plain">var ErrSentinel = errors.New("the underlying sentinel error")

func main() {
	err1 := fmt.Errorf("wrap sentinel: %w", ErrSentinel)
	err2 := fmt.Errorf("wrap err1: %w", err1)
    println(err2 == ErrSentinel) //false
	if errors.Is(err2, ErrSentinel) {
		println("err2 is ErrSentinel")
		return
	}

	println("err2 is not ErrSentinel")
}
</code></pre><p>在这个例子中，我们通过fmt.Errorf函数，并且使用%w创建包装错误变量err1和err2，其中err1实现了对ErrSentinel这个“哨兵错误值”的包装，而err2又对err1进行了包装，这样就形成了一条错误链。位于错误链最上层的是err2，位于最底层的是ErrSentinel。之后，我们再分别通过值比较和errors.Is这两种方法，判断err2与ErrSentinel的关系。运行上述代码，我们会看到如下结果：</p><pre><code class="language-plain">false
err2 is ErrSentinel
</code></pre><p>我们看到，通过比较操作符对err2与ErrSentinel进行比较后，我们发现这二者并不相同。而errors.Is函数则会沿着err2所在错误链，向下找到被包装到最底层的“哨兵”错误值<code>ErrSentinel</code>。</p><p>所以，如果你使用的是Go 1.13及后续版本，我建议你尽量使用<code>errors.Is</code>方法去检视某个错误值是否就是某个预期错误值，或者包装了某个特定的“哨兵”错误值。</p><h2>策略三：错误值类型检视策略</h2><p>上面我们看到，基于Go标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错误处理方可以“有的放矢”的进行值比较之外，并没有提供其他有效的错误上下文信息。那如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。</p><p>这种情况下，我们需要通过自定义错误类型的构造错误值的方式，来提供更多的“错误上下文”信息。并且，由于错误值都通过error接口变量统一呈现，要得到底层错误类型携带的错误上下文信息，错误处理方需要使用Go提供的<strong>类型断言机制</strong>（Type Assertion）或<strong>类型选择机制</strong>（Type Switch），这种错误处理方式，我称之为<strong>错误值类型检视策略</strong>。</p><p>我们来看一个标准库中的例子加深下理解，这个json包中自定义了一个<code>UnmarshalTypeError</code>的错误类型：</p><pre><code class="language-plain">// $GOROOT/src/encoding/json/decode.go
type UnmarshalTypeError struct {
    Value  string       
    Type   reflect.Type 
    Offset int64        
    Struct string       
    Field  string      
}
</code></pre><p>错误处理方可以通过错误类型检视策略，获得更多错误值的错误上下文信息，下面就是利用这一策略的json包的一个方法的实现：</p><pre><code class="language-plain">// $GOROOT/src/encoding/json/decode.go
func (d *decodeState) addErrorContext(err error) error {
    if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) &gt; 0 {
        switch err := err.(type) {
        case *UnmarshalTypeError:
            err.Struct = d.errorContext.Struct.Name()
            err.Field = strings.Join(d.errorContext.FieldStack, ".")
            return err
        }
    }
    return err
}
</code></pre><p>我们看到，这段代码通过类型switch语句得到了err变量代表的动态类型和值，然后在匹配的case分支中利用错误上下文信息进行处理。</p><p>这里，一般自定义导出的错误类型以<code>XXXError</code>的形式命名。和“哨兵”错误处理策略一样，错误值类型检视策略，由于暴露了自定义的错误类型给错误处理方，因此这些错误类型也和包的公共函数/方法一起，成为了API的一部分。一旦发布出去，开发者就要对它们进行很好的维护。而它们也让使用这些类型进行检视的错误处理方对其产生了依赖。</p><p>从Go 1.13版本开始，标准库errors包提供了<code>As</code>函数给错误处理方检视错误值。<code>As</code>函数类似于通过类型断言判断一个error类型变量是否为特定的自定义错误类型，如下面代码所示：</p><pre><code class="language-plain">// 类似 if e, ok := err.(*MyError); ok { … }
var e *MyError
if errors.As(err, &amp;e) {
    // 如果err类型为*MyError，变量e将被设置为对应的错误值
}
</code></pre><p>不同的是，如果error类型变量的动态错误值是一个包装错误，<code>errors.As</code>函数会沿着该包装错误所在错误链，与链上所有被包装的错误的类型进行比较，直至找到一个匹配的错误类型，就像errors.Is函数那样。下面是<code>As</code>函数应用的一个例子：</p><pre><code class="language-plain">type MyError struct {
    e string
}

func (e *MyError) Error() string {
    return e.e
}

func main() {
    var err = &amp;MyError{"MyError error demo"}
    err1 := fmt.Errorf("wrap err: %w", err)
    err2 := fmt.Errorf("wrap err1: %w", err1)
    var e *MyError
    if errors.As(err2, &amp;e) {
        println("MyError is on the chain of err2")
        println(e == err)                  
        return                             
    }                                      
    println("MyError is not on the chain of err2")
} 
</code></pre><p>运行上述代码会得到：</p><pre><code class="language-plain">MyError is on the chain of err2
true
</code></pre><p>我们看到，<code>errors.As</code>函数沿着err2所在错误链向下找到了被包装到最深处的错误值，并将err2与其类型<code> * MyError</code>成功匹配。匹配成功后，errors.As会将匹配到的错误值存储到As函数的第二个参数中，这也是为什么<code>println(e == err)</code>输出true的原因。</p><p>所以，如果你使用的是Go 1.13及后续版本，请尽量使用<code>errors.As</code>方法去检视某个错误值是否是某自定义错误类型的实例。</p><h2>策略四：错误行为特征检视策略</h2><p>不知道你注意到没有，在前面我们已经讲过的三种策略中，其实只有第一种策略，也就是“透明错误处理策略”，有效降低了错误的构造方与错误处理方两者之间的耦合。虽然前面的策略二和策略三，都是我们实际编码中有效的错误处理策略，但其实使用这两种策略的代码，依然在错误的构造方与错误处理方两者之间建立了耦合。</p><p>那么除了“透明错误处理策略”外，我们是否还有手段可以降低错误处理方与错误值构造方的耦合呢？</p><p>在Go标准库中，我们发现了这样一种错误处理方式：<strong>将某个包中的错误类型归类，统一提取出一些公共的错误行为特征，并将这些错误行为特征放入一个公开的接口类型中</strong>。这种方式也被叫做错误行为特征检视策略。</p><p>以标准库中的<code>net包</code>为例，它将包内的所有错误类型的公共行为特征抽象并放入<code>net.Error</code>这个接口中，如下面代码：</p><pre><code class="language-plain">// $GOROOT/src/net/net.go
type Error interface {
    error
    Timeout() bool  
    Temporary() bool
}
</code></pre><p>我们看到，net.Error接口包含两个用于判断错误行为特征的方法：Timeout用来判断是否是超时（Timeout）错误，Temporary用于判断是否是临时（Temporary）错误。</p><p>而错误处理方只需要依赖这个公共接口，就可以检视具体错误值的错误行为特征信息，并根据这些信息做出后续错误处理分支选择的决策。</p><p>这里，我们再看一个http包使用错误行为特征检视策略进行错误处理的例子，加深下理解：</p><pre><code class="language-plain">// $GOROOT/src/net/http/server.go
func (srv *Server) Serve(l net.Listener) error {
    ... ...
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
                // 注：这里对临时性(temporary)错误进行处理
                ... ...
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        ...
    }
    ... ...
}
</code></pre><p>在上面代码中，Accept方法实际上返回的错误类型为<code>*OpError</code>，它是net包中的一个自定义错误类型，它实现了错误公共特征接口<code>net.Error</code>，如下代码所示：</p><pre><code class="language-plain">// $GOROOT/src/net/net.go
type OpError struct {
    ... ...
    // Err is the error that occurred during the operation.
    Err error
}

type temporary interface {
    Temporary() bool
}

func (e *OpError) Temporary() bool {
  if ne, ok := e.Err.(*os.SyscallError); ok {
      t, ok := ne.Err.(temporary)
      return ok &amp;&amp; t.Temporary()
  }
  t, ok := e.Err.(temporary)
  return ok &amp;&amp; t.Temporary()
}
</code></pre><p>因此，OpError实例可以被错误处理方通过<code>net.Error</code>接口的方法，判断它的行为是否满足Temporary或Timeout特征。</p><h2>小结</h2><p>好了，今天的课讲到这里就结束了。在这一讲中，我们重点讲解了Go函数设计中的一个重要环节：<strong>错误处理设计</strong>，希望通过这节课的内容，能帮助你建立起代码设计的意识，提高函数设计的水平。</p><p>Go语言继承了C语言的基于值比较的错误处理机制，但又在C语言的基础上做出了优化，也就是说，Go函数通过支持多返回值，消除了C语言中将错误状态值与返回给函数调用者的信息耦合在一起的弊端。</p><p>Go语言还统一错误类型为error接口类型，并提供了多种快速构建可赋值给error类型的错误值的函数，包括errors.New、fmt.Errorf等，我们还讲解了使用统一error作为错误类型的优点，你要深刻理解这一点。</p><p>基于Go错误处理机制、统一的错误值类型以及错误值构造方法的基础上，Go语言形成了多种错误处理的惯用策略，包括透明错误处理策略、“哨兵”错误处理策略、错误值类型检视策略以及错误行为特征检视策略等。这些策略都有适用的场合，但<strong>没有某种单一的错误处理策略可以适合所有项目或所有场合</strong>。</p><p>在错误处理策略选择上，我有一些个人的建议，你可以参考一下：</p><ul>
<li>请尽量使用“透明错误”处理策略，降低错误处理方与错误值构造方之间的耦合；</li>
<li>如果可以从众多错误类型中提取公共的错误行为特征，那么请尽量使用“错误行为特征检视策略”;</li>
<li>在上述两种策略无法实施的情况下，再使用“哨兵”策略和“错误值类型检视”策略；</li>
<li>Go 1.13及后续版本中，尽量用<code>errors.Is</code>和<code>errors.As</code>函数替换原先的错误检视比较语句。</li>
</ul><h2>思考题</h2><p>这节课，我们列出了一些惯用的错误处理策略，当然，Go社区关于错误处理策略的讨论可能不止这些，你还见过哪些比较实用的错误处理策略吗？不妨在留言区和我们探讨一下吧。</p><p>欢迎你把这节课分享给更多对Go语言的错误处理机制感兴趣的朋友。我是Tony Bai，我们下节课见。</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/19/70/67/0c1359c2.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>qinsi</span>
  </div>
  <div class="_2_QraFYR_0">errors.Wrap多好用</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-04 16:41:48</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2c/06/35/82915b9b.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>五彩斑斓的輝</span>
  </div>
  <div class="_2_QraFYR_0">为什么内置的类型，如int、error等，首字母都是小写的，可以不用遵从首字母大写导出规则，到处都可以使用。是因为它们是在最外层的宇宙代码块里面声明的吗，这在实际上怎么实现的？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: &quot;是因为它们是在最外层的宇宙代码块里面声明的吗&quot; - 是的。<br><br>这些预定义的类型由编译器特殊处理。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-05-19 20:51:49</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/11/66/ac631a36.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Geralt</span>
  </div>
  <div class="_2_QraFYR_0">忽略错误算不算实用的策略呢<br></div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 上生产的代码务必不要忽略错误。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-02 20:49:37</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/16/b7/0e/739fd98a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Digitalization</span>
  </div>
  <div class="_2_QraFYR_0">这节课瞬间看不懂了，是不是最好先讲接口等其他知识点再讲这个呢？好像这节课跟函数没什么关系呀</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 21讲已经覆盖的函数的基本语法，这一讲延展到函数设计之错误处理</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-02-10 00:14:48</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/b0/6e/921cb700.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>在下宝龙、</span>
  </div>
  <div class="_2_QraFYR_0">最后一部分的策略四的设计不是很懂  。。。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 问题再具体一些:)</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-01 10:37:19</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/56/e2/2dcab30d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>郑印</span>
  </div>
  <div class="_2_QraFYR_0">如果函数调用太深，每次做返回值判断都需要写，if err != nil { return err; } 感觉会多出好多的模板代码，有什么好的解决办法吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 目前真的没有。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-23 17:14:07</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/1d/de/62bfa83f.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>aoe</span>
  </div>
  <div class="_2_QraFYR_0">多值返回的错误处理很好用。知道了4种错误使用场景，变强了！</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-02 23:03:47</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/59/28/62ee741f.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>埼玉</span>
  </div>
  <div class="_2_QraFYR_0">if err != nil { return err; }<br><br>看错误怎么能少得了这个 🐶</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-01 18:22:01</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1f/ab/12/170e5c8a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>🦉</span>
  </div>
  <div class="_2_QraFYR_0">请问文章这里<br>var e *MyError<br>if errors.As(err, &amp;e) {<br>    &#47;&#47; 如果err类型为*MyError，变量e将被设置为对应的错误值<br>}<br>&amp;e是pointer e的地址吗？如果是的话为什么这样处理呢？谢谢</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 对，&amp;e是pointer e的地址。因为var err = &amp;MyError{&quot;MyError error demo&quot;}中，err是一个MyError类型的指针，Error方法是*MyError类型的。<br><br>As函数要求，第二个参数应该是实现了error接口的类型的指针。这里*MyError实现了error接口，于是As的第二个参数应该是**MyError类型。<br><br>当然这个例子也可以改写一下：<br><br>package main<br><br>import (<br>	&quot;errors&quot;<br>	&quot;fmt&quot;<br>)<br><br>type MyError struct {<br>	e string<br>}<br><br>func (e MyError) Error() string {<br>	return e.e<br>}<br><br>func main() {<br>	var err = MyError{&quot;MyError error demo&quot;}<br>	err1 := fmt.Errorf(&quot;wrap err: %w&quot;, err)<br>	err2 := fmt.Errorf(&quot;wrap err1: %w&quot;, err1)<br>	var e MyError<br>	if errors.As(err2, &amp;e) {<br>		println(&quot;MyError is on the chain of err2&quot;)<br>		println(e == err)<br>		return<br>	}<br>	println(&quot;MyError is not on the chain of err2&quot;)<br>}<br><br>这样就不用传**MyError了，传*MyError了。因为新版中MyError也实现了error接口。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-01-11 04:15:03</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>罗杰</span>
  </div>
  <div class="_2_QraFYR_0">再读错误处理，依然收获满满。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-01 09:04:27</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1e/f2/f5/b82f410d.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Unknown element</span>
  </div>
  <div class="_2_QraFYR_0">老师我想请教一下错误处理的策略二和策略三的区别是error具体的实现不同吗？哨兵错误处理策略相当于用的还是errorString，而错误值类型检视策略是自定义的struct，可以包含更多上下文？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 从机制上说：策略二是通过值比较进行判定，策略三是通过类型比较进行判定。<br><br>从功能上说：“基于 Go 标准库提供的错误值构造方法构造的“哨兵”错误值，除了让错误处理方可以“有的放矢”的进行值比较之外，并没有提供其他有效的错误上下文信息。那如果遇到错误处理方需要错误值提供更多的“错误上下文”的情况，上面这些错误处理策略和错误值构造方式都无法满足。”</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-10-25 08:37:52</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>冯仁彬</span>
  </div>
  <div class="_2_QraFYR_0">感觉错误处理机制相对于Java没那么好用</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 见仁见智:)</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-09-13 14:48:18</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/68/10/e7a3a167.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Thomas</span>
  </div>
  <div class="_2_QraFYR_0">“因此，OpError 实例可以被错误处理方通过net.Error接口的方法，判断它的行为是否满足 Temporary 或 Timeout 特征。”<br>是否需要否满足 Temporary 或 Timeout 中任意一个特征，e.(net.Error)返回的OK就是true？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: &#47;&#47; An Error represents a network error.<br>type Error interface {<br>    error<br>    Timeout() bool &#47;&#47; Is the error a timeout?<br><br>    &#47;&#47; Deprecated: Temporary errors are not well-defined.<br>    &#47;&#47; Most &quot;temporary&quot; errors are timeouts, and the few exceptions are surprising.<br>    &#47;&#47; Do not use this method.<br>    Temporary() bool<br>}<br><br>net.Error是一个接口，要e.(net.Error)返回的OK，需要实现该接口的所有方法。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-03-27 10:56:14</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/67/3a/0dd9ea02.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Summer  空城</span>
  </div>
  <div class="_2_QraFYR_0">老师，何时使用方法，何时使用函数，指点下呗</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 这问题挺大。在后续讲解接口时会涉及相关内容。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-01 09:27:00</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/4b/ea/a9e7bc50.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>℡人见人爱浩然君゜</span>
  </div>
  <div class="_2_QraFYR_0">越到后面越有点看不懂...<br></div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 建议定期回顾以前的内容，多看即便。另外关于不懂的内容，可以提出有针对性的问题，我会在最短时间内予以解答💪。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-04-07 16:33:28</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/fb/6c/12fdc372.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>迈向架构师</span>
  </div>
  <div class="_2_QraFYR_0">请教下老师：<br><br>&gt; 如果err类型为*MyError，变量e将被设置为对应的错误值<br><br>这里为何要赋值回变量e呢，相当于判断了类型，并且还把原始的错误给提取出来了？<br>后续这个e有什么实际的应用吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 更多是为了取出来用吧，比如调用e.Error()获得error的内容之类的。当然你也可以不用，但作为标准库API的设计者，As函数的设计者肯定要考虑可能这个错误值会被使用的场景。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-02-12 13:23:53</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/26/af/98/5bdfb679.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Mike</span>
  </div>
  <div class="_2_QraFYR_0">func (srv *Server) Serve(l net.Listener) error {    ... ...<br><br>老师好！这是函数吗 func 后面的是什么，不应该跟的是函数名吗？不太明白</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 这个是方法(method)，再往后学几讲就会遇到了:)。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2023-02-08 15:38:50</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/27/05/a2/3fa5a070.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>吃橘子的汤圆🐳</span>
  </div>
  <div class="_2_QraFYR_0">老师您好<br>OpError 是也实现了    Timeout() 吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复:  是的。在net.go源文件中：<br><br>func (e *OpError) Timeout() bool {<br>    if ne, ok := e.Err.(*os.SyscallError); ok {<br>        t, ok := ne.Err.(timeout)<br>        return ok &amp;&amp; t.Timeout()<br>    }   <br>    t, ok := e.Err.(timeout)<br>    return ok &amp;&amp; t.Timeout()<br>}       <br>            </p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-12-08 18:06:33</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTJmCRpUZlm5jaNbpHAk50CWkZwymo599zaThKat1y45JIvV2VU4srpZWCWYttBUGcCDLwtiaodOntQ/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>一支小闲鱼</span>
  </div>
  <div class="_2_QraFYR_0">定义接口让错误方实现这种方式确实好，可以解耦</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-12-04 20:55:24</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTIFEQibKmCdPwFMncjfPFficY97fdnZWFxFbu8uze8REXB5S6gMtxRsESWibBmEFibBsaaj0ZkKmWPtEA/132"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>义务教育漏网之鱼</span>
  </div>
  <div class="_2_QraFYR_0">越来越不适合新手看了。不是说好的 Go语言第一课嘛！跳跃性好大，总拿源码举例！</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-07 12:18:06</div>
  </div>
</div>
</div>
</li>
</ul>