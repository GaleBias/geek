<audio title="06｜构建模式：Go是怎么解决包依赖管理问题的？" src="https://static001.geekbang.org/resource/audio/90/52/90f29b3c6b5ddfa3aa0f7932199f7e52.mp3" controls="controls"></audio> 
<p>你好，我是Tony Bai。</p><p>通过前面的讲解，我们已经初步了解了Go程序的结构，以及Go项目的典型布局了。那么，接下来，<strong>我们是时候来系统学习一下Go应用的构建了</strong>，它们都是我们继续Go语言学习的前提。</p><p>所以在这一节课，我们就来了解Go构建模式演化的前世今生。理解了这个发展史后，我们会重点来探讨现在被广泛采用的构建模式，Go Module的基本概念和应用构建方式。&nbsp;接着，知道了怎么做后，我们会再深一层，继续分析Go Module的工作原理。这样层层深入地分析完后，你就能彻底、透彻地掌握Go Module构建模式了。</p><p>好了，我们直接开始吧。我们先来了解一下Go构建模式的演化过程，弄清楚Go核心开发团队为什么要引入Go module构建模式。</p><h2>Go构建模式是怎么演化的？</h2><p>Go程序由Go包组合而成的，<strong>Go程序的构建过程就是确定包版本、编译包以及将编译后得到的目标文件链接在一起的过程</strong>。</p><p>Go语言的构建模式历经了三个迭代和演化过程，分别是最初期的GOPATH、1.5版本的Vendor机制，以及现在的Go Module。这里我们就先来介绍一下前面这两个。</p><p><strong>首先我们来看GOPATH。</strong></p><p>Go语言在首次开源时，就内置了一种名为<strong>GOPATH</strong>的构建模式。在这种构建模式下，Go编译器可以在本地GOPATH环境变量配置的路径下，搜寻Go程序依赖的第三方包。如果存在，就使用这个本地包进行编译；如果不存在，就会报编译错误。</p><!-- [[[read_end]]] --><p>我这里给出了一段在GOPATH构建模式下编写的代码，你先来感受一下：</p><pre><code class="language-plain">package main

import "github.com/sirupsen/logrus"

func main() {
    logrus.Println("hello, gopath mode")
}
</code></pre><p>你可以看到，这段代码依赖了第三方包logrus（logrus是Go社区使用最为广泛的第三方log包）。</p><p>接下来，这个构建过程演示了Go编译器（这里使用Go 1.10.8）在GOPATH环境变量所配置的目录下（这里为/Users/tonybai/Go），无法找到程序依赖的logrus包而报错的情况：</p><pre><code class="language-plain">$go build main.go
main.go:3:8: cannot find package "github.com/sirupsen/logrus" in any of:
	/Users/tonybai/.bin/go1.10.8/src/github.com/sirupsen/logrus (from $GOROOT)
	/Users/tonybai/Go/src/github.com/sirupsen/logrus (from $GOPATH)
</code></pre><p><strong>那么Go编译器在GOPATH构建模式下，究竟怎么在GOPATH配置的路径下搜寻第三方依赖包呢？</strong></p><p>为了给你说清楚搜寻规则，我们先假定Go程序导入了github.com/user/repo这个包，我们也同时假定当前GOPATH环境变量配置的值为：</p><pre><code class="language-plain">export GOPATH=/usr/local/goprojects:/home/tonybai/go
</code></pre><p>那么在GOPATH构建模式下，Go编译器在编译Go程序时，就会在下面两个路径下搜索第三方依赖包是否存在：</p><pre><code class="language-plain">/usr/local/goprojects/src/github.com/user/repo
/home/tonybai/go/src/github.com/user/repo
</code></pre><p>这里注意一下，如果你没有显式设置GOPATH环境变量，Go会将GOPATH设置为默认值，不同操作系统下默认值的路径不同，在macOS或Linux上，它的默认值是$HOME/go。</p><p>那么，当遇到像上面例子一样，没有在本地找到程序的第三方依赖包的情况，我们该如何解决这个问题呢？</p><p><strong>这个时候就要让go get登场了</strong>！</p><p>我们可以通过go get命令将本地缺失的第三方依赖包下载到本地，比如：</p><pre><code class="language-plain">$go get github.com/sirupsen/logrus
</code></pre><p>这里的go get命令，不仅能将logrus包下载到GOPATH环境变量配置的目录下，它还会检查logrus的依赖包在本地是否存在，如果不存在，go get也会一并将它们下载到本地。</p><p>不过，go get下载的包只是那个时刻各个依赖包的最新主线版本，这样会给后续Go程序的构建带来一些问题。比如，依赖包持续演进，可能会导致不同开发者在不同时间获取和编译同一个Go包时，得到不同的结果，也就是不能保证可重现的构建（Reproduceable Build）。又比如，如果依赖包引入了不兼容代码，程序将无法通过编译。</p><p>最后还有一点，如果依赖包因引入新代码而无法正常通过编译，并且该依赖包的作者又没用及时修复这个问题，这种错误也会传导到你的程序，导致你的程序无法通过编译。</p><p>也就是说，<strong>在GOPATH构建模式下，Go编译器实质上并没有关注Go项目所依赖的第三方包的版本。</strong>但Go开发者希望自己的Go项目所依赖的第三方包版本能受到自己的控制，而不是随意变化。于是Go核心开发团队引入了Vendor机制试图解决上面的问题。</p><p><strong>现在我们就来看看vendor机制是怎么解决这个问题的。</strong></p><p>Go在1.5版本中引入<strong>vendor机制</strong>。vendor机制本质上就是在Go项目的某个特定目录下，将项目的所有依赖包缓存起来，这个特定目录名就是vendor。</p><p>Go编译器会优先感知和使用vendor目录下缓存的第三方包版本，而不是GOPATH环境变量所配置的路径下的第三方包版本。这样，无论第三方依赖包自己如何变化，无论GOPATH环境变量所配置的路径下的第三方包是否存在、版本是什么，都不会影响到Go程序的构建。</p><p>如果你将vendor目录和项目源码一样提交到代码仓库，那么其他开发者下载你的项目后，就可以实现可重现的构建。因此，如果使用vendor机制管理第三方依赖包，最佳实践就是将vendor一并提交到代码仓库中。</p><p>下面这个目录结构就是为上面的代码示例添加vendor目录后的结果：</p><pre><code class="language-plain">.
├── main.go
└── vendor/
    ├── github.com/
    │&nbsp;&nbsp; └── sirupsen/
    │&nbsp;&nbsp;     └── logrus/
    └── golang.org/
        └── x/
            └── sys/
                └── unix/
</code></pre><p>在添加完vendor后，我们重新编译main.go，这个时候Go编译器就会在vendor目录下搜索程序依赖的logrus包以及后者依赖的golang.org/x/sys/unix包了。</p><p>这里你还要注意一点，要想开启vendor机制，你的Go项目必须位于GOPATH环境变量配置的某个路径的src目录下面。如果不满足这一路径要求，那么Go编译器是不会理会Go项目目录下的vendor目录的。</p><p>不过vendor机制虽然一定程度解决了Go程序可重现构建的问题，但对开发者来说，它的体验却不那么好。一方面，Go项目必须放在GOPATH环境变量配置的路径下，庞大的vendor目录需要提交到代码仓库，不仅占用代码仓库空间，减慢仓库下载和更新的速度，而且还会干扰代码评审，对实施代码统计等开发者效能工具也有比较大影响。</p><p>另外，你还需要手工管理vendor下面的Go依赖包，包括项目依赖包的分析、版本的记录、依赖包获取和存放，等等，<strong>最让开发者头疼的就是这一点。</strong></p><p>为了解决这个问题，Go核心团队与社区<strong>将Go构建的重点转移到如何解决包依赖管理上</strong>。Go社区先后开发了诸如gb、glide、dep等工具，来帮助Go开发者对vendor下的第三方包进行自动依赖分析和管理，但这些工具也都有自身的问题。</p><p>就在Go社区为包依赖管理焦虑并抱怨没有官方工具的时候，Go核心团队基于社区实践的经验和教训，推出了Go官方的解决方案：<strong>Go Module</strong>。</p><h2>创建你的第一个Go Module</h2><p>从Go 1.11版本开始，除了GOPATH构建模式外，Go又增加了一种Go Module构建模式。</p><p>在<a href="https://time.geekbang.org/column/article/428267">04讲</a>中，我们曾基于Go Module构建模式编写过一个“hello, world”程序，当时是为了讲解Go程序结构，这里我再带你回顾一下Go Module的基础概念。</p><p>一个Go Module是一个Go包的集合。module是有版本的，所以module下的包也就有了版本属性。这个module与这些包会组成一个独立的版本单元，它们一起打版本、发布和分发。</p><p>在Go Module模式下，通常一个代码仓库对应一个Go Module。一个Go Module的顶层目录下会放置一个go.mod文件，每个go.mod文件会定义唯一一个module，也就是说Go Module与go.mod是一一对应的。</p><p>go.mod文件所在的顶层目录也被称为module的根目录，module根目录以及它子目录下的所有Go包均归属于这个Go Module，这个module也被称为main module。</p><p>你可能也意识到了，Go Module的原理和使用方法其实有点复杂，但“千里之行始于足下”，下面我们先从如何创建一个Go Module说起。我们先来将上面的例子改造成为一个基于Go Module构建模式的Go项目。</p><h3><strong>创建一个Go Module</strong></h3><p>将基于当前项目创建一个Go Module，通常有如下几个步骤：</p><p>第一步，通过go mod init创建go.mod文件，将当前项目变为一个Go Module；</p><p>第二步，通过go mod tidy命令自动更新当前module的依赖信息；</p><p>第三步，执行go build，执行新module的构建。</p><p>我们一步一步来详细看一下。</p><p>我们先建立一个新项目module-mode用来演示Go Module的创建，注意我们可以在任意路径下创建这个项目，不必非要在GOPATH环境变量的配置路径下。</p><p>这个项目的main.go修改自上面的例子，修改后的main.go的代码是这样的，我们依旧依赖外部包logrus：</p><pre><code class="language-plain">package main

import "github.com/sirupsen/logrus"

func main() {
	logrus.Println("hello, go module mode")
}
</code></pre><p>你可以看到，这个项目目录下只有main.go一个源文件，现在我们就来为这个项目添加Go Module支持。我们通过go mod init命令为这个项目创建一个Go Module（这里我们使用的是Go版本为1.16.5，Go 1.16版本默认采用Go Module构建模式）：</p><pre><code class="language-plain">$go mod init github.com/bigwhite/module-mode
go: creating new go.mod: module github.com/bigwhite/module-mode
go: to add module requirements and sums:
	go mod tidy
</code></pre><p>现在，go mod init在当前项目目录下创建了一个go.mod文件，这个go.mod文件将当前项目变为了一个Go Module，项目根目录变成了module根目录。go.mod的内容是这样的：</p><pre><code class="language-plain">module github.com/bigwhite/module-mode

go 1.16
</code></pre><p>这个go.mod文件现在处于初始状态，它的第一行内容用于声明module路径(module path)，最后一行是一个Go版本指示符，用于表示这个module是在某个特定的Go版本的module语义的基础上编写的。</p><p>go mod init命令还输出了两行日志，提示我们可以使用go mod tidy命令，添加module依赖以及校验和。go mod tidy命令会扫描Go源码，并自动找出项目依赖的外部Go Module以及版本，下载这些依赖并更新本地的go.mod文件。我们按照这个提示执行一下go mod tidy命令：</p><pre><code class="language-plain">$go mod tidy
go: finding module for package github.com/sirupsen/logrus
go: downloading github.com/sirupsen/logrus v1.8.1
go: found github.com/sirupsen/logrus in github.com/sirupsen/logrus v1.8.1
go: downloading golang.org/x/sys v0.0.0-20191026070338-33540a1f6037
go: downloading github.com/stretchr/testify v1.2.2
</code></pre><p>我们看到，对于一个处于初始状态的module而言，go mod tidy分析了当前main module的所有源文件，找出了当前main module的所有第三方依赖，确定第三方依赖的版本，还下载了当前main module的直接依赖包（比如logrus），以及相关间接依赖包（直接依赖包的依赖，比如上面的golang.org/x/sys等）。</p><p>Go Module还支持通过Go Module代理服务加速第三方依赖的下载。在<a href="https://time.geekbang.org/column/article/427489">03讲</a>我们讲解Go环境安装时，就提到过GOPROXY环境变量，这个环境变量的默认值为“<strong>https: // proxy.golang.org,direct</strong>”，不过我们可以配置更适合于中国大陆地区的Go Module代理服务。</p><p>由go mod tidy下载的依赖module会被放置在本地的module缓存路径下，默认值为$GOPATH[0]/pkg/mod，Go 1.15及以后版本可以通过GOMODCACHE环境变量，自定义本地module的缓存路径。</p><p>执行go mod tidy后，我们示例go.mod的内容更新如下：</p><pre><code class="language-plain">module github.com/bigwhite/module-mode

go 1.16

require github.com/sirupsen/logrus v1.8.1
</code></pre><p>你可以看到，当前module的直接依赖logrus，还有它的版本信息都被写到了go.mod文件的require段中。</p><p>而且，执行完go mod tidy后，当前项目除了go.mod文件外，还多了一个新文件go.sum，内容是这样的：</p><pre><code class="language-plain">github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE=
github.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=
github.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037 h1:YyJpGZS1sBuBCzLAR1VEpK193GlqGZbnPFnPV/5Rsb4=
golang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
</code></pre><p>这同样是由go mod相关命令维护的一个文件，它存放了特定版本module内容的哈希值。</p><p>这是Go Module的一个安全措施。当将来这里的某个module的特定版本被再次下载的时候，go命令会使用go.sum文件中对应的哈希值，和新下载的内容的哈希值进行比对，只有哈希值比对一致才是合法的，这样可以确保你的项目所依赖的module内容，不会被恶意或意外篡改。因此，我推荐你把go.mod和go.sum两个文件与源码，一并提交到代码版本控制服务器上。</p><p>现在，go mod init和go mod tidy已经为我们当前Go Module的构建铺平了道路，接下来，<strong>我们只需在当前module的根路径下，执行go build就可以完成module的构建了</strong>！</p><p>go build命令会读取go.mod中的依赖及版本信息，并在本地module缓存路径下找到对应版本的依赖module，执行编译和链接。如果顺利的话，我们会在当前目录下看到一个新生成的可执行文件module-mode，执行这个文件我们就能得到正确结果了。</p><p>整个过程的执行步骤是这样的：</p><pre><code class="language-plain">$go build
$$ls
go.mod		go.sum		main.go		module-mode*
$./module-mode 
INFO[0000] hello, go module mode
</code></pre><p>好了，到这里，我们已经完成了一个有着多个第三方依赖的项目的构建了。但关于Go Module的操作还远不止这些。随着Go项目的演进，我们会在代码中导入新的第三方包，删除一些旧的依赖包，更新一些依赖包的版本等。关于这些内容，我会在下一节课再给你详细讲解。</p><p>那么，在看到我们的Go Module机制会自动分析项目的依赖包，并选出最适合的版本后，不知道你会不会有这样的疑惑：<strong>项目所依赖的包有很多版本，Go Module是如何选出最适合的那个版本的呢？</strong>要想回答这个问题，我们就需要深入到Go Module构建模式的工作原理中去。</p><h2>深入Go Module构建模式</h2><p>Go语言设计者在设计Go Module构建模式，来解决“包依赖管理”的问题时，进行了几项创新，这其中就包括<strong>语义导入版本(Semantic Import Versioning)</strong>，以及和其他主流语言不同的<strong>最小版本选择(Minimal Version Selection)</strong>等机制。只要你深入理解了这些机制，你就能真正掌握Go Module构建模式。</p><p><strong>首先我们看一下Go Module的语义导入版本机制。</strong></p><p>在上面的例子中，我们看到go.mod的require段中依赖的版本号，都符合<strong>vX.Y.Z</strong>的格式。在Go Module构建模式下，一个符合Go Module要求的版本号，由前缀v和一个满足<a href="https://semver.org">语义版本</a>规范的版本号组成。</p><p>你可以看看下面这张图，语义版本号分成3部分：主版本号(major)、次版本号(minor)和补丁版本号(patch)。例如上面的logrus module的版本号是v1.8.1，这就表示它的主版本号为1，次版本号为8，补丁版本号为1。</p><p><img src="https://static001.geekbang.org/resource/image/46/a2/468323b3294cce2ea7f4c1da3699c5a2.png?wh=1242x670" alt=""></p><p>Go命令和go.mod文件都使用上面这种符合语义版本规范的版本号，作为描述Go Module版本的标准形式。借助于语义版本规范，Go命令可以确定同一module的两个版本发布的先后次序，而且可以确定它们是否兼容。</p><p>按照语义版本规范，主版本号不同的两个版本是相互不兼容的。而且，在主版本号相同的情况下，次版本号大都是向后兼容次版本号小的版本。补丁版本号也不影响兼容性。</p><p>而且，Go Module规定：<strong>如果同一个包的新旧版本是兼容的，那么它们的包导入路径应该是相同的</strong>。怎么理解呢？我们来举个简单示例。我们就以logrus为例，它有很多发布版本，我们从中选出两个版本v1.7.0和v1.8.1.。按照上面的语义版本规则，这两个版本的主版本号相同，新版本v1.8.1是兼容老版本v1.7.0的。那么，我们就可以知道，如果一个项目依赖logrus，无论它使用的是v1.7.0版本还是v1.8.1版本，它都可以使用下面的包导入语句导入logrus包：</p><pre><code class="language-plain">import "github.com/sirupsen/logrus"
</code></pre><p>那么问题又来了，假如在未来的某一天，logrus的作者发布了logrus v2.0.0版本。那么根据语义版本规则，该版本的主版本号为2，已经与v1.7.0、v1.8.1的主版本号不同了，那么v2.0.0与v1.7.0、v1.8.1就是不兼容的包版本。然后我们再按照Go Module的规定，如果一个项目依赖logrus v2.0.0版本，那么它的包导入路径就不能再与上面的导入方式相同了。那我们应该使用什么方式导入logrus v2.0.0版本呢？</p><p>Go Module创新性地给出了一个方法：将包主版本号引入到包导入路径中，我们可以像下面这样导入logrus v2.0.0版本依赖包：</p><pre><code class="language-plain">import "github.com/sirupsen/logrus/v2"
</code></pre><p>这就是Go的“语义导入版本”机制，也就是说通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本，这样一来我们甚至可以同时依赖一个包的两个不兼容版本：</p><pre><code class="language-plain">import (
    "github.com/sirupsen/logrus"
    logv2 "github.com/sirupsen/logrus/v2"
)
</code></pre><p>不过到这里，你可能会问，v0.y.z版本应该使用哪种导入路径呢？</p><p>按照语义版本规范的说法，v0.y.z这样的版本号是用于项目初始开发阶段的版本号。在这个阶段任何事情都有可能发生，其API也不应该被认为是稳定的。Go Module将这样的版本(v0)与主版本号v1做同等对待，也就是采用不带主版本号的包导入路径，这样一定程度降低了Go开发人员使用这样版本号包时的心智负担。</p><p>Go语义导入版本机制是Go Module机制的基础规则，同样它也是Go Module其他规则的基础。</p><p><strong>接下来，我们再来看一下Go Module的最小版本选择原则。</strong></p><p>在前面的例子中，Go命令都是在项目初始状态分析项目的依赖，并且项目中两个依赖包之间没有共同的依赖，这样的包依赖关系解决起来还是比较容易的。但依赖关系一旦复杂起来，比如像下图中展示的这样，Go又是如何确定使用依赖包C的哪个版本的呢？<br>
<img src="https://static001.geekbang.org/resource/image/49/1b/49eb7aa0458d8ec6131d9e5661155f1b.jpeg?wh=1920x1080" alt=""><br>
在这张图中，myproject有两个直接依赖A和B，A和B有一个共同的依赖包C，但A依赖C的v1.1.0版本，而B依赖的是C的v1.3.0版本，并且此时C包的最新发布版为C v1.7.0。这个时候，Go命令是如何为myproject选出间接依赖包C的版本呢？选出的究竟是v1.7.0、v1.1.0还是v1.3.0呢？你可以暂停一两分钟思考一下。</p><p>其实，当前存在的主流编程语言，以及Go Module出现之前的很多Go包依赖管理工具都会<strong>选择依赖项的“最新最大(Latest Greatest)版本”</strong>，对应到图中的例子，这个版本就是v1.7.0。</p><p>当然了，理想状态下，如果语义版本控制被正确应用，并且这种“社会契约”也得到了很好的遵守，那么这种选择算法是有道理的，而且也可以正常工作。在这样的情况下，依赖项的“最新最大版本”应该是最稳定和安全的版本，并且应该有向后兼容性。至少在相同的主版本(Major Verion)依赖树中是这样的。</p><p>但我们这个问题的答案并不是这样的。Go设计者另辟蹊径，在诸多兼容性版本间，他们不光要考虑最新最大的稳定与安全，还要尊重各个module的述求：A明明说只要求C v1.1.0，B明明说只要求C v1.3.0。<strong>所以Go会在该项目依赖项的所有版本中，选出符合项目整体要求的“最小版本”。</strong></p><p>这个例子中，C v1.3.0是符合项目整体要求的版本集合中的版本最小的那个，于是Go命令选择了C v1.3.0，而不是最新最大的C v1.7.0。并且，Go团队认为“最小版本选择”为Go程序实现持久的和可重现的构建提供了最佳的方案。</p><p>了解了语义导入版本与最小版本选择两种机制后，你就可以说你已经掌握了Go Module的精髓。</p><p>但很多Go开发人员的起点，并非是默认开启Go Module构建模式的Go 1.16版本，多数Go开发人使用的环境中都存在着多套Go版本，有用于体验最新功能特性的Go版本，也有某些遗留项目所使用的老版本Go编译器。</p><p>它们工作时采用的构建模式是不一样的，并且即便是引入Go Module的Go 1.11版本，它的Go Module机制，和后续进化后的Go版本的Go Module构建机制在表现行为上也有所不同。因此Go开发人员可能需要经常在各个Go版本间切换。而明确具体版本下Go Module的实际表现行为对Go开发人员是十分必要的。</p><h2>Go各版本构建模式机制和切换</h2><p>我们前面说了，在Go 1.11版本中，Go开发团队引入Go Modules构建模式。这个时候，GOPATH构建模式与Go Modules构建模式各自独立工作，我们可以通过设置环境变量GO111MODULE的值在两种构建模式间切换。</p><p>然后，随着Go语言的逐步演进，从Go 1.11到Go 1.16版本，不同的Go版本在GO111MODULE为不同值的情况下，开启的构建模式几经变化，直到Go 1.16版本，Go Module构建模式成为了默认模式。</p><p>所以，要分析Go各版本的具体构建模式的机制和切换，我们只需要找到这几个代表性的版本就好了。</p><p>我这里将Go 1.13版本之前、Go 1.13版本以及Go 1.16版本，在GO111MODULE为不同值的情况下的行为做了一下对比，这样我们可以更好地理解不同版本下、不同构建模式下的行为特性，下面我们就来用表格形式做一下比对：</p><p><img src="https://static001.geekbang.org/resource/image/45/d3/45bdecc5fa873e06893d6658e447a8d3.jpeg?wh=1920x1080" alt="图片"></p><p>了解了这些，你就能在工作中游刃有余的在各个Go版本间切换了，不用再担心切换后模式变化，导致构建失败了。</p><h3>小结</h3><p>好了，今天的课讲到这里就结束了，现在我们一起来回顾一下吧。</p><p>在这一讲中，我们初步了解了Go语言构建模式的演化历史。</p><p>Go语言最初发布时内置的构建模式为GOPATH构建模式。在这种构建模式下，所有构建都离不开GOPATH环境变量。在这个模式下，Go编译器并没有关注依赖包的版本，开发者也无法控制第三方依赖的版本，导致开发者无法实现可重现的构建。</p><p>那么，为了支持可重现构建，Go 1.5版本引入了vendor机制，开发者可以在项目目录下缓存项目的所有依赖，实现可重现构建。但vendor机制依旧不够完善，开发者还需要手工管理vendor下的依赖包，这就给开发者带来了不小的心智负担。</p><p>后来，Go 1.11版本中，Go核心团队推出了新一代构建模式：Go Module以及一系列创新机制，包括语义导入版本机制、最小版本选择机制等。语义导入版本机制是Go Moudle其他机制的基础，它是通过在包导入路径中引入主版本号的方式，来区别同一个包的不兼容版本。而且，Go命令使用<strong>最小版本选择</strong>机制进行包依赖版本选择，这和当前主流编程语言，以及Go社区之前的包依赖管理工具使用的算法都有点不同。</p><p>此外，Go命令还可以通过GO111MODULE环境变量进行Go构建模式的切换。但你要注意，从Go 1.11到Go 1.16，不同的Go版本在GO111MODULE为不同值的情况下，开启的构建模式以及具体表现行为也几经变化，这里你重点看一下前面总结的表格。</p><p>现在，Go核心团队已经考虑在后续版本中彻底移除GOPATH构建模式，Go Module构建模式将成为Go语言唯一的标准构建模式。所以，<strong>学完这一课之后，我建议你从现在开始就彻底抛弃GOPATH构建模式，全面使用Go Module构建模式</strong>。</p><h3>思考题</h3><p>今天我们的思考题是：如何将基于GOPATH构建模式的现有项目迁移为使用Go Module构建模式？欢迎在留言区和我分享你的答案。</p><p>感谢你和我一起学习，也欢迎你把这节课分享给更多对Go构建模式感兴趣的朋友。我是Tony Bai，我们下节课见。</p>
<style>
    ul {
      list-style: none;
      display: block;
      list-style-type: disc;
      margin-block-start: 1em;
      margin-block-end: 1em;
      margin-inline-start: 0px;
      margin-inline-end: 0px;
      padding-inline-start: 40px;
    }
    li {
      display: list-item;
      text-align: -webkit-match-parent;
    }
    ._2sjJGcOH_0 {
      list-style-position: inside;
      width: 100%;
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      margin-top: 26px;
      border-bottom: 1px solid rgba(233,233,233,0.6);
    }
    ._2sjJGcOH_0 ._3FLYR4bF_0 {
      width: 34px;
      height: 34px;
      -ms-flex-negative: 0;
      flex-shrink: 0;
      border-radius: 50%;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 {
      margin-left: 0.5rem;
      -webkit-box-flex: 1;
      -ms-flex-positive: 1;
      flex-grow: 1;
      padding-bottom: 20px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2zFoi7sd_0 {
      font-size: 16px;
      color: #3d464d;
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      line-height: 34px;
    }
    ._2sjJGcOH_0 ._36ChpWj4_0 ._2_QraFYR_0 {
      margin-top: 12px;
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-all;
      line-height: 24px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 {
      margin-top: 18px;
      border-radius: 4px;
      background-color: #f6f7fb;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._10o3OAxT_0 ._3KxQPN3V_0 {
      color: #505050;
      -webkit-font-smoothing: antialiased;
      font-size: 14px;
      font-weight: 400;
      white-space: normal;
      word-break: break-word;
      padding: 20px 20px 20px 24px;
    }
    ._2sjJGcOH_0 ._3klNVc4Z_0 {
      display: -webkit-box;
      display: -ms-flexbox;
      display: flex;
      -webkit-box-orient: horizontal;
      -webkit-box-direction: normal;
      -ms-flex-direction: row;
      flex-direction: row;
      -webkit-box-pack: justify;
      -ms-flex-pack: justify;
      justify-content: space-between;
      -webkit-box-align: center;
      -ms-flex-align: center;
      align-items: center;
      margin-top: 15px;
    }
    ._2sjJGcOH_0 ._3Hkula0k_0 {
      color: #b2b2b2;
      font-size: 14px;
    }
</style><ul><li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/7a/d4/aa028773.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>张诚</span>
  </div>
  <div class="_2_QraFYR_0">目前网上讲包管理讲得最清晰最全面的内容了。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 过奖了:)</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 16:24:30</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/26/27/eba94899.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>罗杰</span>
  </div>
  <div class="_2_QraFYR_0">从构建来看，现在的确是掌握 Go 的好时机。之前入坑的时候，gopath 真的让人抓狂。</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 09:42:10</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/c6/20/124ae6d4.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>若水清菡</span>
  </div>
  <div class="_2_QraFYR_0">之前看过两个老师讲go，上来基本上都适合先语法规则后实践的路线，每次go build都一脸懵逼，看下来还是不了解go的编译过程~~~~tony bai老师讲的非常好，遇到一位合适自己的老师，希望跟着学完这门课程，非常感谢老师~</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 嗯嗯，这次的思路是先让大家上手。但作为入门课，后续必然也会对Go语法进行讲解与深入理解的。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-11-14 11:05:10</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/27/f3/08/1e8432bc.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>本</span>
  </div>
  <div class="_2_QraFYR_0">if go version &lt; 1.13: 项目移出GOPATH&#47;src<br>go env -w GO111MODULE=on<br>go mod init module_path<br>go mod tidy<br></div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 17:58:25</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/14/9d/a4/e481ae48.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>lesserror</span>
  </div>
  <div class="_2_QraFYR_0">感谢 Tony Bai 老师的分享，每篇文章我都认真拜读了。<br><br>本着持续精进的目的，每篇文章我都会提出一些自己的疑问，麻烦老师抽空解答一下。<br><br>1. 在$GOPATH模式下，寻找第三方包依赖的顺序是不是：先找 $GOROOT 然后找  $GOPATH。<br><br>2. go.sum文件的工作原理后面能否详细讲讲吗？ 感觉这里的讲解还是简单带过了。<br><br>3. 文中说：“Go 团队认为“最小版本选择”为 Go 程序实现持久的和可重现的构建提供了最佳的方案。” 这句话能展开讲讲吗？ 感觉没明白其中的意思。<br><br>4. 第4讲说到：“Go 支持在一个项目 &#47; 仓库中存在多个 module，但这种管理方式可能要比一定比例的代码重复引入更多的复杂性。”  如果项目中引入了第三方 module，比如这篇文章中也引入了第三方 module，这种情况属于 :  &quot;在一个项目 &#47; 仓库中存在多个 module&quot; 的情况吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你的提问就是对专栏最好的支持，手工点赞！<br><br>下面回答你的问题：<br><br>1. 从gopath模式下，go build命令的输出来看，是这样的。<br>2. go.sum机制对于大多数开发人员都是透明的，属于高级话题。因此，在我的这个以入门和基础为重的专栏中并未深入展开。后&gt;续我可能会在自己的博客或公号上谈谈go.sum机制，到时候，你可以去看看。<br>3. 相较于选择最新最大版本，选择最小版本出于几个考虑吧：<br><br>1）对开发者而言，更易于理解和预测，就像课程中例子那样，我们根据依赖图可以很容易确定程序构建最终使用的依赖版本。<br>2) 对go核心团队来说，更容易实现，据说实现最小选择的代码也就几十行。<br>3) 更重要的是最小版本选择更容易实现可重现构建。试想一下，如果选择的是最大最新版本，那么针对同一份代码，其依赖包的最新最大版本在不同时刻可能是不同的，那么在不同时刻的构建，产生的最终文件就是不同的。<br>                                              <br>当然这一切的前提都是基于语义版本规范，对于不符合规范的module，相当于没有遵守契约，这套规则也就失效。这对任何语言来<br>说都是一样的。<br>                                                                       <br>                                                                       <br>4. 不属于。04讲说的那种情况是指在一个项目仓库中的不同目录下放置了多个go.mod，即一个项目中有多个module。<br>     <br><br></p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 23:45:56</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/1a/67/51/ee740f03.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>丶能</span>
  </div>
  <div class="_2_QraFYR_0">提问！<br>“选择符合项目整体要求的最小版本”是可能选择，依赖最小版本与最新版本中任意版本，还是项目引入版本中的可选范围内的最小版本呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 按照课程中的例子，A 要求 &gt;=C v1.1.0，B 要求 C &gt;=v1.3.0，那么选择同时满足A与B要求的最小版本，就是v1.3.0。如果选择v1.1.0则不满足A要求。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 22:01:57</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/18/d8/8b/d81769bf.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>太匆匆</span>
  </div>
  <div class="_2_QraFYR_0">默认是是最小版本原则，能否修改默认呢？比如举例当中的v1.1.0、v1.3.0、v1.7.0默认会选v1.3.0，开发者能否将其改成v1.7.0呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 好问题！可以通过go get xxx@v1.7.0显式更新go.mod中的依赖版本。或通过go mod edit命令或直接编辑go.mod进行。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-03-23 23:21:29</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>flexiver</span>
  </div>
  <div class="_2_QraFYR_0">老师，您好。想要请问解答两个问题： 1、请问在构建module时， go mod init -module path, 这个module path 是固定要写成github.com&#47;module name这样一个结构吗？ </div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 好问题！不必要非得是github.com，也不必要非得是github.com&#47;module name这样的。你可以使用module demo1这样的path。不过module path有三个作用，根据需要作出path的选择：<br><br>1. 定位代码仓库位置。如果你的代码是开源到一些公共代码托管站点，或者在组织内部的代码仓库时，path中要带上仓库的地址，比如github.com&#47;repo&#47;module，这样依赖你的module的其他代码可以找到你的module代码。<br>2. 如果你的module不在repo的根路径下，那么在module path中还要包含子目录路径。以github.com&#47;etcd-io&#47;etcd这个仓库为例。这个仓库下管理着多个go module。以其子目录raft下面的module为例，这个module的path为：module go.etcd.io&#47;etcd&#47;raft&#47;v3。其中的raft就是子路径。<br><br>3. major版本号。如果major&gt;=2，需要在module path中加上major号后缀。就像上面的module go.etcd.io&#47;etcd&#47;raft&#47;v3。<br><br></p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-03-13 18:49:19</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/2d/1e/4a93ebb5.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Aaron Liu</span>
  </div>
  <div class="_2_QraFYR_0">看起来有点像node module，初学者从go module开始构建会比较好，理解一个方式</div>
  <div class="_10o3OAxT_0">
    
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 08:09:38</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/2a/eb/a4/b247e9b7.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>独钓寒江</span>
  </div>
  <div class="_2_QraFYR_0">老师你好，最近 log4j 和 logback 都被发现了安全漏洞，很多Java程序都受到影响，修复起来工作量也不小。如果类似情况出现在Go方面，例如 logrus 出了安全漏洞，我们需要修改依赖版本, 我们可以怎么应对呢？可以简单说说吗？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 你这个问题很&quot;与时俱进&quot;啊:)。首先对于已经依赖logrus的版本的go项目，go build不会自动更新logrus到其最新版本，也就不会受到故意漏洞的侵害。假设你的项目在go mod init时获取到的是最新漏洞版本或通过go get logrus@latest获取到其漏洞版本，那么可以看一下07讲，将版本降级或升级到漏洞修复后的版本，操作步骤专栏里都有的。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-12-25 13:30:23</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/79/96/fb0d8a65.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>李亮</span>
  </div>
  <div class="_2_QraFYR_0">关于依赖管理的文档在这里：https:&#47;&#47;go.dev&#47;doc&#47;modules&#47;managing-dependencies</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-11-01 11:06:05</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/0f/54/9a/76c0af70.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>每天晒白牙</span>
  </div>
  <div class="_2_QraFYR_0">老师，请教个问题，我是go1.16.4版本，按照老师在文中所说，GO111MODULE 应该为on呀，而我的确实空<br>(base) ➜  ~ go env<br>GO111MODULE=&quot;&quot;<br>GOARCH=&quot;amd64&quot;<br>....<br>GOVERSION=&quot;go1.16.4&quot;</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 所谓默认为on是指，如果GO111MODULE没有显式设置，那么默认为on。你这里环境变量GO111MODULE为空，那么go编译器默认GO111module为on。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-05-10 22:34:03</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/27/af/fd/a1708649.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>ゝ骑着小车去兜风。</span>
  </div>
  <div class="_2_QraFYR_0">之前做过一个go的项目，用的iris框架，然而拉下来的包始终没有我需要的那个方法，纠结了好久都没办法解决。 现在终于知道是iris框架更新了，导致主板本号不同，需要的那个方法也变成另一个方法了。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-04-30 09:58:39</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/12/04/25/a384ee7a.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>李进</span>
  </div>
  <div class="_2_QraFYR_0">作为go的入门者，一直觉得没有理解理解GO的包的依赖管理和mod机制，读了老师的几篇文章，终于理解了。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 👍</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-04-18 15:12:28</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src=""
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>rocshen</span>
  </div>
  <div class="_2_QraFYR_0">目前看过课程结构设计最合理的教程  给老师点赞</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 感谢支持。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-03-06 09:15:02</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/29/b0/d3/200e82ff.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>功夫熊猫</span>
  </div>
  <div class="_2_QraFYR_0">其实这几天我难受的是自定义的包导入的问题。</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 这个go 1.18应该可以彻底解决。通过go.work。可以看看这个特性的前瞻：https:&#47;&#47;mp.weixin.qq.com&#47;s&#47;AGAz8dti8IwfVntOvBTUTg</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-11-15 01:54:17</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://wx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTKY0SBAOch2S7wadCRFKTT5fBtXCvsa46svoTj2MWoQ9YRrujZuq4wEHjS9dCEzPcrWHNSYgUkNVw/0"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>林</span>
  </div>
  <div class="_2_QraFYR_0">这位老师的文章犹如编程爽文，看的过瘾</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 哈哈，过奖了</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-11-05 13:41:54</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/20/1e/18/9d1f1439.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>liaomars</span>
  </div>
  <div class="_2_QraFYR_0">把GOPATH构建下的项目目录复制一份出来，在这个目录下面开启 GO MODULES，执行：go mod init &amp;&amp; go mod tidy</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 提示：go mod init后面要加上module path哦。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-26 16:55:54</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/11/b8/21/41823347.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>Harold</span>
  </div>
  <div class="_2_QraFYR_0">语义版本不能算go mod创新吧</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 语义版本是独立的。但go module的“语义导入版本”机制的确与众不同。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2021-10-25 14:46:28</div>
  </div>
</div>
</div>
</li>
<li>
<div class="_2sjJGcOH_0"><img src="https://static001.geekbang.org/account/avatar/00/10/82/42/8b04d489.jpg"
  class="_3FLYR4bF_0">
<div class="_36ChpWj4_0">
  <div class="_2zFoi7sd_0"><span>刘丹</span>
  </div>
  <div class="_2_QraFYR_0">请问老师：如果 myproject 有两个直接依赖 A 和 B，A 和 B 有一个共同的依赖包 C；但 A 依赖 C 的 v1.1.0 版本，不兼容 C 的 V1.3.0 版本；而 B 依赖的是 C 的 v1.3.0 版本，不兼容 C 的 v1.1.0 版本；并且此时 C 包的最新发布版为 C v1.7.0。这种情况下要怎样处理呢？</div>
  <div class="_10o3OAxT_0">
    <p class="_3KxQPN3V_0">作者回复: 像你的问题中的情景，go module会根据MVS原则选择C v1.3.0。但go module依赖管理的前提是：语义版本(semver)。而你问题中说：v1.1.0和v1.3.0不兼容，这本身就违反了go module的前提。那么即便go选择了v1.3.0也会导致编译失败。这时就需要手工介入了。</p>
  </div>
  <div class="_3klNVc4Z_0">
    <div class="_3Hkula0k_0">2022-05-01 09:28:57</div>
  </div>
</div>
</div>
</li>
</ul>